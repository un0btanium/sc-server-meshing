[
    {
        "uuid": "e17143ca39f9723fc4640df4e014c475676fa216",
        "index": 1
    },
    {
        "uuid": "0bf2ca4937e639b25bee86072d4aa7d72cef9f3b",
        "index": 2
    },
    {
        "uuid": "b9b6f8d3bec5aa2e08be3571d54e5cd92a2007e8",
        "index": 3,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing Welcome",
        "subtitle": "",
        "texts": [
            "Welcome to the Unofficial Road to Dynamic Server Meshing! This presentation is trying to offer a centralized place about almost everything related to Dynamic Server Meshing."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/4/2/1/7/3a28ad54a1e87d3e9e82d69287e1200.png"
    },
    {
        "uuid": "0b14bb137a5afeb88e0508e31775daccc435ead5",
        "index": 4,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing Welcome",
        "subtitle": "",
        "texts": [
            "We will go over the the major and minor technologies that create the functionality of Dynamic Server Meshing. For each tech feature, an overview slide summarizes the technical challenges and CIG's approach to enable the required functionality. For all of the major tech features, there have been additional slides provided which dive into more detail.",
            "There are also some introductory topics which go over some of the basic concepts in hardware, software and video games, which try to convey a basic understanding of their inner workings and limitations. Of course, you can skip them and jump right in by reading about the Object Container tech. But I will always recommend checking the introductory topics out if you do have the time and interest.",
            "What to expect from this presentation:"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/1/4/0/1/dd320a147fdb35ef5cdf6ff31b41200.png"
    },
    {
        "uuid": "b5aad4e67edfb7d05a04674624fcbf345c984508",
        "index": 5,
        "pageIndicators": {
            "current": "3",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing Welcome",
        "subtitle": "How to navigate this presentation",
        "texts": [
            "You can see the page number of the current topic in the bottom right corner of your screen (e.g. for this slide it says 5 total slides and we are currently on the 3rd slide). To go back and forth between the slides, you can use the left and right arrow keys on your keyboard or the buttons at the bottom of the page. Pressing backspace always brings you up one level.",
            "You can check out individual technologies freely by clicking on them with your mouse. You can also zoom in and out of topics with your mouse wheel. However I recommend reading this presentation in order, because of the nature of these technologies building upon and utilizing each other."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/4/8/2/d/a08d2b24be480dbc756482e70881200.png"
    },
    {
        "uuid": "e269243e8625b98d7da723c0b66f2ba4fdfcde71",
        "index": 6,
        "imageURLs": [
            "https://media.preziusercontent.com/media/b/f/c/d/d/8b930ec4032a4ea3a6293ac6b3c.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing Welcome",
        "subtitle": "Visual Examples",
        "texts": [
            "Throughout this presentation, I tried to incorporate images to help visualize how these technologies work and what their purposes are.",
            "So lets get started! The usual game level is three dimensional and therefore has three axis (x, y and z). We will leave out the z dimension and represent the level as a flat 2D area. We do this for simplicity reasons, but remember that all the presented technologies are actually operating in 3D. A first example of a level can be seen in the image below. It features two players (blue and red) inside the level.",
            "On the following slides you find further explanations and visual representations of technical topics that will lay the foundation for all the subsequent technologies."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/4/7/e/e/4/f09069a4f45a1890295e5dd33971200.png"
    },
    {
        "uuid": "0b07510d1656606d85cd16ea0edc6ce69250ecde",
        "index": 7,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing Welcome",
        "subtitle": "",
        "texts": [
            "Even though there was a great effort made to use official information and sources, be aware that some aspects of how these technologies work are deduced and therefore speculated. Whenever that was the case, I tried to make sure that it was noted as such, either in the slide title or in the text itself, so have a lookout for them. Therefore, the information presented here are my own understanding at this moment in time and are therefore subject to change. In the light of additional insights, the information in this presentation will be updated accordingly. Feel free to contribute with information that I may have missed.",
            "Feel free to check out the sources that were used in creating this overview for yourself. I listed all of them at the end of this presentation.",
            "If you feel like something is missing, incorrect, incomplete, unclear or you just have a question or just want to say hello, feel free to notify me on Spectrum:",
            "https://robertsspaceindustries.com/spectrum/community/SC/forum/3/thread/road-to-dynamic-server-meshing-tech-overview-with-",
            "Quick Disclaimer before we start"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/4/4/e/d/e/7af9e9f48fa94c8f42f1dd784ae1200.png"
    },
    {
        "uuid": "25feff7813fde15ceb6a6b5e020aedcf09e2a4c8",
        "index": 8
    },
    {
        "uuid": "df410d6e54a35cc1e3629aa4b66f5c79b5de8f38",
        "index": 9,
        "pageIndicators": {
            "current": "1",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Introduction",
        "subtitle": "How does the computer compute?",
        "texts": [
            "1",
            "0",
            "when electrons are moving,",
            "when electrons are not moving.",
            "Let us start from the very bottom and build our way up:",
            "Electrons move through conduit material.",
            "This allows us to represent different states:",
            "We can then use tiny transistors to control this flow of electrons.",
            "A transistor acts like a switch. But instead of manually switching it by hand - like we would a normal button switch - a transistor can be automatically controlled, by another electron flow. This allows state/data to change automatically.",
            "When putting multiple transistors together in specific configurations, they create logic gates. And putting multiple logic gates together, one can perform binary math, comparisons, etc."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/d/3/4/8/f/52fb5e048c9ad388fca1a47fc701200.png"
    },
    {
        "uuid": "c620f297f475d58c71584816a85738b4bd53821a",
        "index": 10,
        "pageIndicators": {
            "current": "2",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Introduction",
        "subtitle": "How does the computer compute?",
        "texts": [
            "Since electrons require time to flow through the logic gates, to give them enough time to do so, we introduce a CPU clock. And we only check the resulting state at certain time intervals, meaning after each clock cycle.",
            "Depending on the clock speed, modern CPUs can have billions of clock cycles each second. For example a CPU with a clock speed of 4.0 GHz can perform 4.000.000.000 clock cycles per second! That makes each clock cycle last 0.25 nanosecond (that's 0.00000000025 seconds). Light in a vacuum merely travels 7 centimeters in that time span (~2,8 inches)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/e/8/b/8/44f53fb4aec98556a64a91c3c311200.png"
    },
    {
        "uuid": "0783af19c840f7bc68792dd7b4e6ae4821f98e1b",
        "index": 11,
        "pageIndicators": {
            "current": "3",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Introduction",
        "subtitle": "How does the computer compute?",
        "texts": [
            "In each clock cycle, we can tell the CPU what to compute. Rather than having to tell the CPU where electrons need to flow, the CPU provides us with a defined set of instructions, a CPU instruction set, which abstracts all of that low-level hardware stuff away for us. In each clock cycle, we can have the CPU execute one such instruction.",
            "Different instructions are responsible for different things: some instructions do math, others compare, move data around in memory or even alter the execution of our program.",
            "CPU instructions are the interface between the hardware (our logic gates) and the software. Executing multiple CPU instructions in sequence (or even in parallel) allows us to perform more complex calculations and logic. Programs emerge.",
            "Note: These days, modern CPUs are further optimized and can sometimes perform multiple instructions in one clock cycle.",
            "Note: All software programs written in a programming language are translated into these CPU instructions at some point. The CPU does not know about any programming languages, except its instruction set. But since instructions are very very atomic operations, programming languages abstract these away to help us create complex programs easier and faster."
        ],
        "sources": [
            "w12"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "b35a07e91fd34d61ed56389f90e7a3aa7a22431f",
        "index": 12,
        "pageIndicators": {
            "current": "4",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Introduction",
        "subtitle": "How does the computer compute?",
        "texts": [
            "In video games, we can use these instructions to simulate a game world. This game world is directly made up of game objects. Updating each game object requires a certain amount of instructions to perform its simulation logic. For example, their change in position and orientation in the game world, as well as other state attributes of the object (e.g. a door might be in an open, close, opening or closing state).",
            "But remember that there can only be one instruction executed in each clock cycle? And we \"only\" have e.g. 4.0GHz = 4.000.000.000 clock cycles (and thus instructions) per second available? This means we are limited in the amount of instructions per second. And this consequently means we are also limited in the number of game objects we can update and simulate. Although, the number of instructions a game object requires may vary, as it depends on the complexity of the game object.",
            "So when adding more and more game objects, eventually, we won't have enough instructions available to update all of them in a timely manner. We are not allowed to skip the update of game objects as that would seemingly \"freeze\" parts of the game world. Instead, the next round of updates for ALL game objects is delayed. This is usually referred to as 'low tickrate' and will talk more about tickrate and the game loop later."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/e/2/3/5/5730ddc4ac3a3abfe244a3a17d21200.png"
    },
    {
        "uuid": "ff8cf1a14f36622826268327e896e43231c0bf03",
        "index": 13,
        "pageIndicators": {
            "current": "5",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Introduction",
        "subtitle": "How does the computer compute?",
        "texts": [
            "Of course to support more game objects, we could simply throw faster hardware at the problem. Use a CPU with 5.0GHz instead. Done! However, this only works up to a certain point. There are hard limits to hardware and better hardware becomes exponentially more expensive as well. Using better hardware is called vertical scaling.",
            "Another and more promising option is horizontal scaling. Here, we simply use another CPU, an additional computer. By using multiple computers, each one with a CPU, connecting them via a network and having them exchange relevant data, they can work on a much larger workload.",
            "If done right, as in having solved memory management, loading of data (memory is still limited resource on each machine, so as the game world grows not every game object needs to be loaded into memory), game simulation (a game object doesnt have to be simulated on all machines, but just one), networking (data is only send to computers that need it) and persistence (read and write data in databases for later use), then you have huge amounts of processing power at your finger tips. You could execute trillions of instructions across hundreds of computers/servers each second and simulate a large, game object-rich game world.",
            "Note: As is often the case, it is more complicated than this, but this is a good first introduction of what Dynamic Server Meshing is about."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/8/2/0/2/1e39aa240a89f5dd24a58f809101200.png"
    },
    {
        "uuid": "8ce8ce18b182f72744c9e5addd1a8c6bd57d51a7",
        "index": 14
    },
    {
        "uuid": "9391b307a9e68b3f3760330e864e7729367bdfd8",
        "index": 15,
        "imageURLs": [
            "https://media.preziusercontent.com/media/d/0/d/5/a/f709d6b4bd496c1a59dffbc6d0c.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Overview of Computer Hardware and its Limitations",
        "texts": [
            "Some more technical background information first! A computer usually consists of 5 major parts:",
            "* Drive (HDD/SSD/NVMe)",
            "* Random Access Memory (RAM)",
            "* Central Processing Unit (CPU)",
            "* Graphics Processing Unit (GPU)",
            "* Mainboard"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/0/4/0/8/44ba73c45c78b79cb9162257b7a1200.png"
    },
    {
        "uuid": "773e921a71f86f2790c6ef8d5179bce3efe8ff7a",
        "index": 16,
        "imageURLs": [
            "https://media.preziusercontent.com/media/d/0/d/5/a/f709d6b4bd496c1a59dffbc6d0c.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Overview of Computer Hardware and its Limitations",
        "texts": [
            "Drive (HDD/SSD):",
            "Digital data can be persistently stored on drives. Data can be loaded from and saved to",
            "the drive. Data can be stored on mass, like terabytes of data on a single drive, since drives can be cheaply produced. Hard Disk Drives (HDDs) have mechanical parts and are therefore slower when it comes to read and write speeds. Solid State Drives (SSDs) are not mechanical and therefore data can be directly read and written, resulting in much faster read and write speed performances, but consequently are more expensive.",
            "Random Access Memory (RAM):",
            "Another way to store data is in the Random Access Memory. This type of memory performs even faster than SSDs when it comes to read and write speeds, however makes it even more expensive which is why RAM is usually in the ranges of a few gigabytes (4-32GB), not terabytes like drives are. However, data in RAM is volatile, meaning that if power is cut, the data stored in the RAM is lost, making RAM a great (because fast) storage while the computer is running and processing data, but useless as a long term storage device once the computer is turned off."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/6/0/b/1/6ff4d264a7a9fa6e1f5126f7bc61200.png"
    },
    {
        "uuid": "a7deb5237c31d790cee12f8077c46cedd3ad7fa2",
        "index": 17,
        "imageURLs": [
            "https://media.preziusercontent.com/media/d/0/d/5/a/f709d6b4bd496c1a59dffbc6d0c.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Overview of Computer Hardware and its Limitations",
        "texts": [
            "Central Processing Unit (CPU):",
            "The CPU is responsible for the execution and monitoring of code instructions which allows the computer to be programmed by software for various purposes. The CPU transforms data from one state/form into another by making calculations and logic comparisons. While the CPU itself has a few MB of very fast memory (L1, L2 and L3 memory cache), the CPU still heavily utilizes the RAM to load and save data. The program that runs on the CPU determines which data is loaded from the drive into RAM (as well as saving data from the RAM onto the drive). This usually happens when the program is started, but data can also be loaded/streamed-in while it is running.",
            "Graphics Processing Unit (GPU):",
            "While the CPU is great at certain tasks like program execution, it usually is not great at rendering digital images fast. Another processing unit designed specifically for rendering graphics called the GPU allows for much faster and better results. It also has its own form of memory, the VRAM, to store textures and assets. The CPU usually tells the GPU via a rendering API what it should render.",
            "Mainboard:",
            "All these previous parts are connected with each other via the mainboard. All computer components communicate over connections, called the bus system (e.g. PCI and SATA). They basically are data highways from one component to another, the flow of data being controlled by the CPU."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/1/7/5/8/5cc2c0b4bd289097f576ddde09e1200.png"
    },
    {
        "uuid": "5a2c506b12eda0e5b7d35a515b9d749038cafea9",
        "index": 18,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png",
            "https://media.preziusercontent.com/media/c/b/0/5/d/a2a42b84144b875e82266e0a7ab.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Overview of Computer Hardware and its Limitations",
        "texts": [
            "So what do all of these components do? It comes down to executing code: commands which instruct the computer to perform math and logic on the data in memory. These code instructions alter the data, turning that data from one state into another state. And depending on the processor architecture, cores and clock speed (e.g. 4.8GHz) there can be multiple billion instructions executed per second. Those results are then send over a network and/or used to create an image on our monitor screens.",
            "In the example on the right, we have four instructions that load two values from memory (from the two memory addresses 128 and 256) then perform addition on them and the result is stored back into memory at memory address 128 (essentially overwriting the previous value that was stored there). In the context of a videogame, these could be the position x and the velocity vx of our player character. So the computer calculated our character's next position in the level. More on this \"Game Update Loop\" chapter in this Introduction.",
            "1) load r1, 128",
            "2) load r2, 256",
            "3) add r3, r1, r2",
            "4) store r1, 128"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/1/9/3/c/216361246edb07d29f26708c7d11200.png"
    },
    {
        "uuid": "8fa2382178d50dd5ca66f51816662c6ab00446db",
        "index": 19,
        "imageURLs": [
            "https://media.preziusercontent.com/media/d/0/d/5/a/f709d6b4bd496c1a59dffbc6d0c.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "5"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Overview of Computer Hardware and its Limitations",
        "texts": [
            "In general, all computer components have their own limitations. Memory (drives",
            "and RAM) are limited by how much maximum data capacity they have as well",
            "as how fast they can read and write data (and if they are volatile or not).",
            "Meanwhile, processing units (CPUs and GPUs) are mostly about how many code",
            "instructions they can execute each second, as well as how fast they are able to access the data from the memory devices.",
            "With these limitations all software is created, games included. CIG set out to create a large universe with thousands of players, NPCs and other entities which all require to be in memory and need to be computed by the CPU in the game loop (and rendered on the GPU). Not even the most powerful computer will be capable of providing that much memory and computational power on its own.",
            "Therefore, the load has to be distributed onto multiple computers/CPUs and connected over a network, to let the computers communicate and exchange only the currently relevant data with each other. Mainly the game servers need this functionality while the players only need to connect to a small amount of game servers at any given point in time and load and compute only the entities close to them. Such a system is generally called a Server Mesh, because multiple servers are being meshed together over a network (local or over the internet). That makes multiple computers act as one large one with a lot of memory and lots of computation power. This is the system Star Citizen plans to utilize to create its vast and rich universe."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/8/d/0/0/76a2ac04863acf2683a6354b7931200.png"
    },
    {
        "uuid": "020103073acba628305b1694f64493acaf036522",
        "index": 20
    },
    {
        "uuid": "9aee02ad5df90309b2ad11bac3a7691c0e807713",
        "index": 21,
        "imageURLs": [
            "https://media.preziusercontent.com/media/3/2/e/3/5/3c5ccd0486b958f8c74089399d5.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Networking - The Client-Server Architecture",
        "texts": [
            "Since Star Citizen is a multiplayer online game with many players playing in the same game world, the data has to be shared and communicated between the players over the internet. Star Citizen uses the common client-server architecture to accomplish this.",
            "In such an architecture, you usually have a computer that acts as the server and other computers which act as the clients. All computers are connected over a network (e.g. the internet). The clients can connect themselves to the server and then the server and the clients can exchange information over the network between each other. Clients don't establish connections between each other, and instead all clients are connected to the server. The server distributes/relays the information from one client to the other clients.",
            "In the case of Star Citizen, each player starts their game and their game client will establish a connection to a game server. The game server runs just another instance of the game, just like the player game clients. However, the server instance is special because it does not actually act as a player. The server simulates the game world while listening to the incoming actions from the player clients, then sends the resulting changes back to all clients which will then in turn update their own game world accordingly.",
            "Since communication between multiple computers over a network always introduces latency between the sending and receiving of data packages, the state of the game world will always be slightly different on each player client and the server. To ensure that the game provides a reliable gameplay experience for all players, the server instance is deemed to be the \"ground truth\" about the state of the game world. Basically the server has the authority of the game state. That means that the player clients will always trust the data that comes from the server over its own current world state. Since the server always simulates the game world and thus",
            "validates the player actions, this guarantees that all clients will stay synchronized with the server and that",
            "the game world a player sees wont deviate drastically from what other players see on their screens."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/1/4/e/2/b583b5649a8af21686921a98c9a1200.png"
    },
    {
        "uuid": "9b40bfcef3418ef49d27d21432a63e1b1e2dbc49",
        "index": 22
    },
    {
        "uuid": "6ab8a0b150365310d9742163dae81798c2c2a1c1",
        "index": 23,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png",
            "https://media.preziusercontent.com/media/9/a/e/3/1/18912304fe6a203c04099ac946e.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop",
        "texts": [
            "Games come to life thanks to the game update loop. It simulates the game world by updating all entities multiple times a second. Doing one cycle in the loop is considered to be one game tick and many games execute around 30 game ticks per second.",
            "At the start of each game tick, the game processes the input done by the player. For multiplayer games it also checks for any network updates that were received. The game world is then simulated by executing the update logic of entity (dynamic game objects) in the game world (more on this in the next slides). Once that is done, the game may send the changes made over the network (to a server or client). On the game client, it then triggers the graphics renderer to have it prepare and render a new frame which will then be displayed on the player's monitor.",
            "Server Meshing is about the Simulation and Networking parts of the game update loop to having multiple game servers work together to simulate the same game world without being noticeable for the players."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/b/6/f/1/88652cb4a2197cfc5f00cf461a81200.png"
    },
    {
        "uuid": "db0cde5e454f0f49f76c111e3ce9f3600ff895b8",
        "index": 24,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/d/e/d/b/d9dfad34c7196589220ec9d1f69.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop - Game Simulation 1/4",
        "texts": [
            "For the state of each entity, there is an area of memory reserved. Each location in memory can be addressed by a unique \"identifier\": its memory address. Therefore, memory can be thought of as one long tape where data/values/state can be read from, changes made and written back to.",
            "On each game tick, the state of the entities are updated when the game is simulated. For example, the position of the entity (e.g. a player or spaceship) in the game world.",
            "In the image on the right we have a player positioned at coordinate x=10 and y=25. Those two values exist at the memory addresses 192 and 256."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/2/3/b/c/a543b174c76bac9f98f7e3b90061200.png"
    },
    {
        "uuid": "876bb456246faf29e1592d607531e40fffff1f58",
        "index": 25,
        "imageURLs": [
            "https://media.preziusercontent.com/media/f/1/a/c/3/aac81c74345a3d8d8adf5005d67.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop - Game Simulation 2/4",
        "texts": [
            "On each game tick when simulating, these values are read and then incremented by the current velocity of the player, then saved back in the same position in memory.",
            "In our example on the right, in the first game tick, the x position was increased by 5 and the player moved a short distance in the game world.",
            "A game tick can be thought of like one \"move\" when playing a board game. Just that all object in the game world receives their move in one game tick. So all objects make their move at once and, ideally, 30 times per second."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/d/6/6/3/0d5139443d681e1603d61bb92491200.png"
    },
    {
        "uuid": "fa6699da1532ef227a95fc1f213802c1932ff9bc",
        "index": 26,
        "imageURLs": [
            "https://media.preziusercontent.com/media/4/c/8/7/0/23784764c72a301dfc2c686cdcb.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop - Game Simulation 3/4",
        "texts": [
            "In the second game tick, both x and y values were increased by 5 and the player moved a small distance diagonally."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/d/7/6/d/3/02a9e184dd3b45a32dcbdb8e63e1200.png"
    },
    {
        "uuid": "1d6a3c643e2e63850c1c4c98f374dc9ee06645af",
        "index": 27,
        "imageURLs": [
            "https://media.preziusercontent.com/media/6/d/7/b/8/cfdae924919a99b33fc55b6dcc8.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop - Game Simulation 4/4",
        "texts": [
            "Therefore, on each game tick, all entities only ever teleport from one position to the next. Smooth motion emerges because they are updated and teleported multiple times a second (~30 times). This is how the game world is simulated on the CPU.",
            "These values (and/or player inputs/actions) may be send over a network (to either the clients or the server) as well as used to render an image on the player client's GPU.",
            "In terms of rendering, there are a few tricks like Interpolation to have smooth motion of entities when the frame rate is higher than the update tick rate of the game loop. E.g. with 30 game ticks/sec but 60fps, every second position of an entity is estimated on the current and previous position to ensure smooth motion on screen.",
            "TODO: collision checks between game objects"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/4/1/3/c/2/45519204a70bbf9b3af3b56bd0b1200.png"
    },
    {
        "uuid": "da09ad92c4d9e4ab5347f7dab09405f50c89071a",
        "index": 28,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png",
            "https://media.preziusercontent.com/media/7/7/d/6/f/e433eef438a9044dfa07030d47f.png"
        ],
        "pageIndicators": {
            "current": "6",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop - Networking Entity State 1/3",
        "texts": [
            "Whenever there was a change in the game world - that is after the simulation - the game server prepares a data packet with these changes. In our case, it uses the x and y coordinates."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/1/3/a/3/db148a14ff192020536e886ed2d1200.png"
    },
    {
        "uuid": "41b485964260b6c64b6620d66b9369e463243762",
        "index": 29,
        "imageURLs": [
            "https://media.preziusercontent.com/media/b/4/e/f/3/cec18a34f1ea2f4a49e59a06a22.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "7",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop - Networking Entity State 2/3",
        "texts": [
            "This data packet is then send over the network to the clients."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/f/c/9/e/f299cce415dad3e260397fe46141200.png"
    },
    {
        "uuid": "a00c7348179ceb2cdc580047a5a9142f705fa34b",
        "index": 30,
        "imageURLs": [
            "https://media.preziusercontent.com/media/5/1/f/8/c/9d8fd3b4db6a4d5be7c870982a5.png",
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "8",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop - Networking Entity State 3/3",
        "texts": [
            "Each client receives the data packet, opens it and saves it into its memory. Now the client would be up to date with the server again and reflect the current state of the game world (e.g. by rendering a frame on the screen).",
            "Although in the image, the coordinate values were saved at the same memory address on the client, in a real application they usually are in different locations in memory. Each computer manages their own memory and determines for itself to which memory addresses the values have to be saved. This just covers the basic networking logic. There are further optimizations (such as client-side prediction and server reconciliation) which is generally know as netcode. However, we wont go into too much detail on such optimizations over the course of this presentation. This current knowledge on networking game state will suffice for now."
        ],
        "sources": [
            "s105",
            "n1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/d/4/8/a/e457ba645a0870e3bce83a676611200.png"
    },
    {
        "uuid": "8cf5ceb3a675f269431c0b75cb47a63aa0328f29",
        "index": 31,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png",
            "https://media.preziusercontent.com/media/2/f/6/8/1/633409c4790a83c7a88fb6e85c4.png"
        ],
        "pageIndicators": {
            "current": "9",
            "total": "9"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Game Update Loop",
        "texts": [
            "However, one important note before we continue: In most online games, the client usually simulates the game world just like the server does. This is done because exchanging data via a network introduces latency. While waiting for the server network updates to come back, the client will use information from the previous entity state updates send from the server (essentially the entities' last known actions) to simulate and therefore predict the entities behavior. Later, the network update from the server will be used to ensure its correctness and correct the client's entities state if necessary. This solution helps with creating a smoother experience for the client while benefiting from the server verification at the same time."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/1/2/2/2/464bf7a494d907f61f9c545446d1200.png"
    },
    {
        "uuid": "0d6b10caa86229f56114ead90d19b6e2f501d0e9",
        "index": 32
    },
    {
        "uuid": "338868bf36806d2262d1d3c8a55b8930976d46e4",
        "index": 33,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Frame Rate and Game Ticks - Difference between Rendering (GPU) and the Game Loop (CPU)",
        "texts": [
            "One important topic we should discuss as well is the difference between Frame Rate (Rendering on the GPU) and Game Ticks (Game Simulation and Networking on the CPU).",
            "The game loop is executed by the CPU, not the GPU. That is because the game code and game logic is executed on the CPU. If there was no game loop, then no changes would happen in the game, and the GPU would only ever render the same image/frame with no changes over and over again. Only because of the game loop, it is made possible that objects change state in the game world. The CPU periodically sends the current information of the objects of the game world to the GPU to have it create a new image. This is done by the renderer, also running on the CPU, which optimizes the scene data before it is send to the GPU. There are a few tricks like Interpolation to have smooth motion of objects at high frame rates even if the game loop only runs at 30 ticks per second.",
            "Since the game servers only need to simulated the game world, they just run the game loop without rendering the game (which actually frees up some CPU load because the CPU does not have to tell the GPU what it is supposed to render). Thus there usually is no GPU installed in the computer configuration of game servers.",
            "Note: Sometimes the game tick rate on the server is referred to as frame rate as well. Frame here refers to a frame of time or execution, and not an image.",
            "Every game has a game loop in its code to simulate that time has passed in the game world. In each game loop cycle, called a \"game tick\", all/some objects in the game world are being updated as well as the inputs of the players handled to have an effects in the game world. In many games, the game loop is set to 30 ticks per second (every 33.3 milliseconds one tick), in some highly competitive games up to 64 and even 128 ticks per second to allow for the reaction time of players to matter more. The game tick rate is usually independent from the frame rate.",
            "The frame rate is usually determined by how many images/frames the render engine and the GPU can create within one second. This is usually determined by a lot of factors, like what the renderer and GPU are capable of, how many objects are on screen, in which ways the objects are being rendered, etc. At 24+ frames per second (fps), the brain is tricked into seeing motion. In recent years, especially in the competitive gaming scenes, monitor screens allow for 144fps and more. Of course, the GPU still has to be capable of providing these high frame amounts first before they can be displayed."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/e/d/6/e/11a9fd44bac977c133f6dccf6791200.png"
    },
    {
        "uuid": "4b1cf4f571f475c3d65ccb363da7f91992f1bf9c",
        "index": 34
    },
    {
        "uuid": "e718ba034d32375fb3cd12c7df8218307041b0cc",
        "index": 35,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/b/8/e/c/32328d144f7b2a626649d75d086.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Road to Dynamic Server Meshing - Preamble",
        "subtitle": "Objects and Entities (and Components)",
        "texts": [
            "One last topic before we can finally start our journey toward Dynamic Server Meshing is the difference between objects, entities and components in the game.",
            "The game world is usually created out of static objects. These objects are usually floors, walls, ceilings, stairs, planet surface, etc. These static objects are pure geometry and do not have any special behavior attached to them (except maybe a separate hitbox for collision checks) and therefore do not have to be updated in the update loop at all. Thus, they are very cheap objects CPU computation-wise and merely need to be rendered on the GPU.",
            "However, games usually feature dynamic objects as well, like players, NPCs, ships, other vehicles, doors, etc. Essentially everything that moves, interacts or has behaviors are considered dynamic objects. They are usually referred to as entities (entity in singular) and are the ones which are updated in the game loop on the CPU.",
            "Based on the number of game tick per second the game runs on, the CPU only has a few milliseconds to go through all entities that require an update and update them. Star Citizen has a tick rate of 30 and therefore 33 milliseconds (ms) computation time available for each game tick. Usually a modern computer can handle a few thousand entities depending on the complexity of those entities. When there are too many entities or too many complex entities being updated, then the game starts to slow down which can have a noticeable impact on the player experience. Therefore, the goal is to keep the entity computation low enough for a smooth experience by staying under those 33ms for each game tick.",
            "As we will see later, Star Citizen reworked its entity system to an Entity Component architecture and splits each individual behavior in the game into its own component which then can be attributed to any entity. Therefore, it matters how many components are being updated in the game update loop, not necessarily the amount of entities."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/9/5/c/3/82cabe145c0a3fa1396fa545ba51200.png"
    },
    {
        "uuid": "021530e528f3346f5c73a2633d38e0c631fa213d",
        "index": 36
    },
    {
        "uuid": "1d0f3d284f2701c1ad655bb756ec6c93c1be731b",
        "index": 37
    },
    {
        "uuid": "f3b0c55f37b73f7bff813d0585c3c8d2c62ad387",
        "index": 38,
        "pageIndicators": {
            "current": "1",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "Introduction",
        "texts": [
            "Our multi-step journey to Dynamic Server Meshing begins with the creation of Object Containers.",
            "Challenges:",
            "* traditional game levels consist of a list of objects (static and dynamic) which are loaded all on level start behind a loading screen",
            "* to eventually be able to create a seamless universe with no loading screens and thousand of players, we can't load all objects into our memory all at once since the large amount of data would exceed our memory capacity",
            "Solution: Object Containers",
            "Goals:",
            "* instead of designing a level, introduce the idea of level building blocks called Object Containers which make up individual parts of the level from which the entire level is made out of",
            "* this will later allow parts of the level to be loaded and unloaded into/from the level at anytime while playing",
            "* this requires the functionality to stream objects in and out of memory, even after the initial process of loading the level finished",
            "* the current system does not allow for such functionality, so we need to implement a unified system which will allow objects to be loaded at any time",
            "* it will then be used to build upon toward the final Server Meshing implementation where different parts of the level is going to be computed by different game servers.",
            "Approach:",
            "* put all unique objects referencing their resources (like geometry, assets and entity type) into their own Object Containers",
            "* allow Object Containers to reference and have other Object Containers as children so that the final level emerges out of many nested Object Containers",
            "* rework the existing levels to use the Object Containers and create all future content with Object Containers which requires changes to the engine editor",
            "* on level start, load the level via the Object Containers. There does not exist any logic yet that loads Object Containers while playing and will be the functionality later introduced by Object Container Streaming which loads/unloads objects at any time",
            "* Object Containers themselves were first introduced in Alpha 2.6.1 (Feb 2017) but many of the other features (Megamap, 64bit coordinates, Entity Components, etc.) made its debut with Alpha 3.0 (December 2017)"
        ],
        "sources": [
            "jp1",
            "cc2df2",
            "atv1",
            "atv4"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/1/0/7/b/08451ac4c66bc2b7334a94146fa1200.png"
    },
    {
        "uuid": "0db6b569968d18243917bebaf088592401bf5178",
        "index": 39,
        "imageURLs": [
            "https://media.preziusercontent.com/media/0/5/4/5/3/5864a8545578e06ed919e929c2a.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "Example",
        "texts": [
            "In the visual example on the left, we have loaded three players into the level. The red and green players are near each other on the same planet while the blue player is on a different planet far away. However, to avoid visual clutter, the planets, ships and other objects were left out of the image and we only show the connected players. We are going to revisit this example in the upcoming major technologies again.",
            "Underneath, we also see a visual representation of the load on the individual computer components. The load on the CPU (blue) and GPU (red), how much RAM (orange) is in use, which part of the drive we loaded into memory (grey area). In this case the data of all objects were loaded from drive into memory, the load of CPU and GPU and memory occupied is quite high. (In the context of Server Meshing, the GPU is not as relevant as the CPU and memory.)",
            "With the level split into different building blocks (Object Containers), the game could load and unload parts of the level at anytime. Therefore, we would only ever need to load the parts of the level into memory which are near and visible to the player (like a few kilometer sphere around the player) instead of having to load the entire level from drive into memory. This allows the game to keep memory consumption low enough to not exceed the maximum memory capacity.",
            "However, the functionality to stream objects from the drive into memory after the initial level load wasn't actually introduced yet with the release of the Object Containers. The player client and game server still had to load all objects of the level at its initial load because there was no logic yet that would tell client and server which objects it should load or unload. The functionality for streaming objects in and out of a level at any time became only possible with the introduction of Object Container Streaming which we will talk more about later."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/4/e/4/f/e9db6104476972332b1edff537b1200.png"
    },
    {
        "uuid": "33eaefd865c7de9ebb2e5e2d1d1b55478728dfb2",
        "index": 40,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/5/3/0/0/2fbc4014f7da4c48fc5ca3b5283.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "The Implementation 1/3",
        "texts": [
            "Object Containers are wrappers for object types. A container acts as a template from which one or multiple instances (entity) of the same object type can be created. An entity might a player character, coffee cup, a ship or even planets and solar systems. Each object type (and thus Object Container) might have a unique identifier (either a name or a number) with which it can be referred. Each container has a list of the resources it uses, e.g. models, geometry, textures, zones and entity components.",
            "Some Object Containers might represent atomic objects. Others Object Container may represent an entire or partial level. This is done because Object Container can reference of other Object Containers. Thus, Object Containers can be nested. A tree structure of Object Containers is created. For example the Stanton system would be a Object Container which references the Stanton star and its four planetary systems as its child Object Containers. The landing zone Area 18 would be referenced from the ArcCorp planet container, and so on."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/9/7/a/0/9/c7dfa6a469db810b2c3647bb3671200.png"
    },
    {
        "uuid": "d5c365971c0c8d90d90e9ed519f28da4ec043c10",
        "index": 41,
        "imageURLs": [
            "https://media.preziusercontent.com/media/a/9/4/7/e/5cf6444430ca87f058ac470368b.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "The Implementation 2/3",
        "texts": [
            "With Object Containers the level is now split into individual building blocks. Artists and developers do not develop individual levels anymore, but instead individual objects or parts of a level. Those can then be reused anywhere in the level and be part of other Object Containers. Therefore, the final level is made up of nested Object Containers from which game objects (entities) are spawned.",
            "An artist making a change to an object container, changes all entities that originate from that object container in all places in the level. For example, a chair design used all across a landing zone. Instead of having to make changes to all hundred chairs individually, the artists just have to make the change once to the chair Object Container. This makes it easy to make changes, rework and update existing objects without having to update every single object individually. Just the Object Container has to be altered."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/c/f/4/3/7/c63ada545f9b577069748ca61de1200.png"
    },
    {
        "uuid": "55552cad5ed44e4cceb5acd6072ac9906625ff73",
        "index": 42,
        "imageURLs": [
            "https://media.preziusercontent.com/media/9/1/d/c/5/714ca05498cb6ef76cff6c3cac5.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "The Implementation 3/3",
        "texts": [
            "When an object is loaded into the level, either on initial level load or later while playing, the Object Container is loaded into memory. Then a new object is created from the Object Container. This is done by allocating the required space in memory to later hold the object's state (like position). The resources that are listed in the container, like textures and geometry, are loaded into memory into the MegaMap and/or into the memory of the GPU.",
            "The MegaMap consists of various memory managers which check, if a resource was already loaded by other objects. If that is the case then the already loaded resource is simply reused rather than loading it again which would waste memory space by introducing duplicates. The object is initialized with its values and positioned into the level. Most of these values are going to be loaded from a save file but later are going to be loaded out of a database. An Object Container can consist of multiple child Object Containers which will be loaded and initialized and relatively positioned to its parent object into the level (for example, the clothes a character wears, the gun that is attached to the character and the bullets that are in its magazine and bullet chamber).",
            "Once loading and initializing is done, and the object is dynamic - meaning it has behavior and can be interacted with - then this entity is ready to be computed by the CPU in the game update loop, thus state changes and stuff happens in the game world, e.g. a player or NPC can walk around, a ship can fly, a terminal can be accessed, a ship spawned, a wall can be run into, etc."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/5/f/8/7/8937152463f94338ed3d783ead41200.png"
    },
    {
        "uuid": "af955ded819bf386abec2a03d4cc8748990d846f",
        "index": 43,
        "imageURLs": [
            "https://media.preziusercontent.com/media/8/9/c/4/6/d5fecad489090e86bc22ba17bc0.png",
            "https://media.preziusercontent.com/media/c/c/4/4/8/44934b84d668602bfa26b463211.png"
        ],
        "pageIndicators": {
            "current": "6",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "Entity Components",
        "texts": [
            "Alongside the development of Object Containers, CIG also reworked the entire simulation code of the engine. They rewrote the code by splitting and reusing code pieces across multiple different object types.",
            "An entity is not just a whole thing. It consists of many small behaviors and interactions, like physics, player health, movement input, etc. Each of these behaviors were put into their own Component. And thus there exists a PhysicsComponent, a HealthComponent, a InputComponent, etc. When a new entity is spawned, then the components of that entity are initialized and memory reserved to hold their state. The entity is therefore a composition of components.",
            "In the code, these components can then be used on different entities, speeding up development and reducing bugs by not having to write or copy the same code over and over again into different object types. For example, player characters, ships and other items can all make use of the same PhysicsComponent, to experience gravity and other forces as well as collide and bounce off each other. Of course, depending on the behavior of the object, it will be attributed different Components. For example, not all entities need the InputComponent, only the player character."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/b/c/6/d/aa35be74a9887e60af912b88c8f1200.png"
    },
    {
        "uuid": "7881a235496d9b7a950ce69599458ffa1d63db01",
        "index": 44,
        "imageURLs": [
            "https://media.preziusercontent.com/media/c/9/3/c/3/7156940414f90c66429d7819c63.png",
            "https://media.preziusercontent.com/media/6/9/e/d/c/bca111e4ed39c0d0c666064cbe2.png"
        ],
        "pageIndicators": {
            "current": "7",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "Zone System",
        "texts": [
            "Additionally, the new Zone System (speculated: a custom hybrid between a space partitioning data structure and a scene graph) splits the game world into areas. All objects inside such an area are grouped together. For example, a zone can be a spaceship. All objects inside that spaceship are grouped, thus being part of that zone. When the spaceship moves, its zone is moved as well, thus moving all objects inside of the spaceship with it. This is made performant by giving each zone its own coordinate system and objects inside are placed and moved relative to the zone center coordinate instead of the game world level center coordinate. And thus, the positions of the objects inside do not need to be updated when the ship moves.",
            "This system replaces the old Octree partitioning system. Octrees split the game world in cubic, immovable chunks. Each cube can be split into 8 smaller sub-cubes. Those sub-cubes can be split into 8 more cubes again. Rinse and repeat. In memory, a tree structure emerges which can be traversed by all sorts of algorithms. The image shows the difference between Octrees and Zones. Be aware that our level example is 2D, thus we are actually showing Quadtrees (the 2D version of the 3D Octrees, using squares instead of cubes thus splitting a square into 4 sub-squares).",
            "With the 64bit conversion, the levels have become extremely large. The Zone System splits the game world much more efficiently, as it is able to concentrate on areas where lots of objects and activity are, instead of splitting empty space into hundreds of empty cubes which creates larger tree data structures which requires more memory and takes longer to traverse.",
            "The Zone System is used for optimizing rendering, physics collisions as well as for networking entity updates and loading/streaming objects in Object Container Streaming. The room atmosphere and physics grid systems are (most likely) directly build upon the zone system as well."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/2/5/3/0/3/0635f834a76a308f6ac30f31e9e1200.png"
    },
    {
        "uuid": "fb9cdddc4868920e20369a069675673f9aeb80f2",
        "index": 45,
        "imageURLs": [
            "https://media.preziusercontent.com/media/3/b/0/4/8/699a1da4d689badeb97e338518d.png"
        ],
        "pageIndicators": {
            "current": "8",
            "total": "8"
        },
        "title": "Object Container",
        "subtitle": "Serialized Variables (API)",
        "texts": [
            "Optimization was done on the networking to reduce bandwidth. On each game tick the server has to send the state of entities to the player clients. With the high amount of data of entities in Star Citizen, this will result in a lot of data and thus bandwidth. Therefore, CIG implemented an system which detects any entity state changes. It then only sends those changed values across the network instead of the entire state of the entity, which would include unchanged values as well. This network optimization made it possible to reduce the bandwidth up to 80% for certain Entity Components."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/9/7/7/a/f/73737cd48ed916355c5b8b01cd71200.png"
    },
    {
        "uuid": "a034331b21ec9f3eb5a8ed910b1d33157fb99e59",
        "index": 46
    },
    {
        "uuid": "3134ef19a4741275fe57e9d267001ade99f45331",
        "index": 47,
        "pageIndicators": {
            "current": "1",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "[jp1,cc2,rtv2,rtv1,s111,s113,",
        "texts": [
            "pn33,pn335,w1,lc1]",
            "Overview",
            "With Object Containers it is now possible to split a level into separate game areas and load them into a level anytime. However, that functionality cant be utilized yet. Client Object Container Streaming (sometimes Client Side OCS or CSOCS or COCS) sets out to change that.",
            "Challenges:",
            "* by increasing the amount of objects in the level, more and more system memory is required",
            "* by adding more entities into the level, the load on the CPU for entity computation each game tick increases",
            "* the CPU of the client has to keep entities in sync with the server by updating its state",
            "* too many entities computed currently results in not enough CPU load available to help render the game",
            "* frame rate and performance on the client drops",
            "Solution: Client Object Container Streaming, an intermediate step toward complete Object Container Streaming",
            "Goals:",
            "* reduce the memory requirements on the player client",
            "* reduce the load on the CPU on the player client",
            "* allow for more objects and entities to be added into the level on the server (e.g. more planets, locations and players)",
            "Approach:",
            "* reduce memory usage by only loading the nearby/visible objects of the level around the player",
            "* dynamically stream Object Containers in and out of the level while the player is traveling across the level or entities (like other players and their ships) approaching/leaving the player",
            "* the server notifies the player clients whenever the player clients should load objects",
            "* streaming entities in and out reduces the amount of entities that have to be computed by the client CPU",
            "* for far away entities, the server stops/skips network updates based on the entity's distance to the player to save client CPU usage"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "dc60ed46848d7473f45ea118c7748e81a2b4b1a0",
        "index": 48,
        "imageURLs": [
            "https://media.preziusercontent.com/media/9/1/b/6/1/8dfb4144402812aac8b0358a7ff.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Initial Situation",
        "texts": [
            "Without Client Object Container Streaming, all clients and the server have the entire level loaded. This means that all object have to be loaded from drive into memory on level start or when connecting to the server. The server CPU computes all objects/entities and sends state updates to the clients via messages over the network/internet. This leads to CPU usage on the player client being quite high because it receives information about all objects in the level as well as the CPU having to help prepare the next frame to be rendered as well.",
            "The client is overloaded with too much information and the CPU cant help render the game as much anymore and even the frame rate starts to suffer. The server does not have that additional load since no graphics are being rendered on it, only the entities updated on each game tick.",
            "In the picture on the left, at the top, we can see that the entire level is loaded (white area is loaded). CPU (blue) and memory usage (orange) are quite high since all entities are loaded from drive into memory and being computed on the CPU."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/1/f/8/8/48bbea44e7ea6ead830d8e7c0751200.png"
    },
    {
        "uuid": "a4ce79b85a9e7389c58f79eedd684dff0a722e7f",
        "index": 49,
        "imageURLs": [
            "https://media.preziusercontent.com/media/8/e/7/3/b/280705b4a6c854a7e5dbd2fb5e1.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "The Solution 1/2",
        "texts": [
            "With Client Object Container Streaming, clients do not have to load the entire level anymore, only the nearby objects around them. This may be another player standing right in front of the player, the enemy space ship the player is shooting at, the space station in orbit, or the moon far away in the sky. Which objects are being loaded is determined by how far away and how large the object is, so that the moon in the sky will be computed and",
            "displayed but not the small players which are on that far away moon.",
            "In the picture on the left, we now see that for each player client only the area around that player is loaded. The remaining level is not loaded which is represented with the greyed out areas. We also see the expected reduction in memory usage (orange) and the load on the CPU (blue) since we have to load less data into memory and need to update less entities on each game tick.",
            "(Note: All percentages are purely for visualization, not real world performance statistics!)"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/d/3/4/3/581ba3f489aba8b7eec905bc3111200.png"
    },
    {
        "uuid": "1114d397545ab391fbb6ac374eaae61ab88a734a",
        "index": 50,
        "imageURLs": [
            "https://media.preziusercontent.com/media/6/1/6/b/b/25ffe4c4d83b597841db8ea77ed.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "The Solution 2/2",
        "texts": [
            "When a player moves around in the level, object containers behind/far away from the player can be being unloaded while object containers that are about to come 'into view in front' of the player are being loaded into memory (e.g other players, ships and items) (Note: \"view\" refers to objects all around the player, not just the objects directly in front where the player is currently looking at, since the players view can change rapidly, faster than data can be loaded from drive into RAM.) This requires communication between the client and the server where the server notifies the client to load objects via Object Container into memory.",
            "In the example on the left, the blue player (Client A) moved around in the level toward the red player. As the red player came into view, he was loaded into memory on the blue players computer and started receiving updates from the server to stay in sync. The same for the red player who loaded the blue player into memory and started computing him each tick."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/f/b/5/c/63fa2f8408c9e607f0b31c926581200.png"
    },
    {
        "uuid": "1179294160f290847039e9311d5e11ee307f9512",
        "index": 51,
        "pageIndicators": {
            "current": "5",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Multiple systems working together",
        "texts": [
            "Since the client does not need to know about all entities that are on the server anymore, Client OCS and its functionality was initially referred to under the name Network Bind Culling (or Network LOD). Essentially the data on the client is culled via the network by the server. However, it seems as if Network Bind Culling is just one part of many that brought us the final Client OCS functionality. Here is a quick summary:",
            "Serialized Variables: Introduce network update policies to entities and their variables, e.g. a variable being constantly networked on each game tick or only when its state changed to reduce and optimize network bandwidth.",
            "Entity Component Update Scheduler: Provides information of how far away an object is to the player. It supported the functionality of starting and stopping (essentially skipping) network updates of entities that are too far away from *all* players.",
            "Serialized Variable Culling: The Entity Component Update Scheduler stopped networking entities to the clients that were too far away from all players, but all clients still were send network updates of all entities around ALL players on that server, no matter how far apart the players were from each other. Serialized Variable Culling changed that: The server now only sends each client the updates of entities which are near that specific player, not all players anymore.",
            "Network Bind Culling: The previous features were only about limiting network updates, all entities were still loaded on the client even if they did not receive network updates anymore. This was changed with Network Bind Culling. This feature added the functionality for the server to tell the client when to load objects on each client from/into memory. This makes use of the Object Containers.",
            "With Client OCS, a player client is able to load and stay in sync with the entities on the server which are relevant to that specific client. Therefore, information on the client has been reduced, selected based on the object size and distance to the player in the level. More features, like loading these objects into memory in the background in other CPU threads as well as the Serialized Variables feature for efficient networking, accumulated in the final Client OCS feature."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/b/e/6/7/470a07e4243b4d69fd57c307a721200.png"
    },
    {
        "uuid": "e123af35aefeecf76779390a6d2ad521980d089a",
        "index": 52,
        "imageURLs": [
            "https://media.preziusercontent.com/media/1/d/3/b/9/dda27034bafb97c4ccc5610fbb6.png"
        ],
        "pageIndicators": {
            "current": "6",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "The streaming bubble",
        "texts": [
            "The bubble doesnt actually exist as such. We are just using it to visualize more easily that stuff is loaded around the player. But in reality, whats loaded are the individual game objects.",
            "(On a similar note, the actual (empty) space of a level doesnt need to be loaded, as 'nothingness' does not have to be represented as a game object in memory).",
            "But we might think of the bubble as the spatial query which determines which game objects to load. This makes use of the 3D 64bit geohash \"StarHash\" and a Radix Tree which are suited to perform such spatial queries. It factors in the distance between each game object and player, as well as the size of each object.",
            "Therefore far away and/or small objects might not be loaded because those wouldnt be visible to the player anytime soon. Likewise, objects that are really large - like moons or planets -might still be loaded from far away. With Object Containers being nested, not all contents of a location need to be loaded all at once either. While the planet ArcCorp might be loaded already, the Area 18 city or parts of its interior might not be loaded yet as it is still too small. In a similar fashion, these small objects are unloaded first as well when a player departs and moves away from such location."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/d/2/9/2/f/6a4193a4676bb31d5d62741eb9d1200.png"
    },
    {
        "uuid": "f61ea0d23b72eacda7f66af921fb166d529d66b4",
        "index": 53,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/1/7/d/c/93e7b3a43a982d7614b3d787a5d.png"
        ],
        "pageIndicators": {
            "current": "7",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Client OCS in-depth 1/5",
        "texts": [
            "So how does the client load objects?",
            "Afterall, the client cant simply use a level save file anymore to load entities, since now those initially only exists in the game server's memory. The client only has a small section of the game world loaded, and everything that isn't loaded is therefore unknown to the client. Thus, it has to be the game server that has to let the client know which objects to load.",
            "In our case, the red player client does not know about the blue player yet, because the blue player is on the other side of the level and too far away still. But, the blue player is traveling toward the red player's position. So lets see how this plays out."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/d/1/e/b/c56f74543708928c04a27fe422e1200.png"
    },
    {
        "uuid": "921655e9adeccb3741d99408635ce1f1b587f06a",
        "index": 54,
        "imageURLs": [
            "https://media.preziusercontent.com/media/0/4/a/a/5/76fd5904564be3a5d21ce9e362c.png"
        ],
        "pageIndicators": {
            "current": "8",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Client OCS in-depth 2/5",
        "texts": [
            "Once an object moves close enough to a player, the server notices this and considers it relevant for that specific player client. Again, this also takes into account the size of the object, not just the distance to the player. Once identified, the server makes use of Object Containers to communicate it to the client.",
            "Both the client and the server have the same list of Object Containers and each Object Container has the same identifier. In our example, player characters have the id #001. This allows the server to sends a network packet to our red client, which contains the Object Container ID #001.",
            "This reduces the network bandwidth required while playing the game. Sending only the identifier of an Object Container means that the server does not have to send the actual Object Container itself nor any resources associated with the Object Container. Resources like textures, geometry, sounds, etc. are all downloaded onto the player's drive while downloading and patching the game. That is also the time when the list of Object Containers is downloaded."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/6/5/3/2/00f5903456bb9695e42864665f21200.png"
    },
    {
        "uuid": "875014f37346e0a802d55aad5d2fa2c4fb2555c1",
        "index": 55,
        "imageURLs": [
            "https://media.preziusercontent.com/media/e/8/d/2/8/2936d2f4e2f97469442b6da0aa9.png"
        ],
        "pageIndicators": {
            "current": "9",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Client OCS in-depth 3/5",
        "texts": [
            "Once the player client receives the network packet, it will use the ID to look up the Object Container its own list of Object Containers. In this case, it will find the player character object. This Object Container acts as a blueprint to spawn new player characters from. So all player characters are spawned from the same Object Container.",
            "However, not all players are the same, for example the player wears have different armor and holds a coffe cup. So the server might already sends additional information and more Object Container IDs within the same network packet already.",
            "Even tho the blue player character is now loaded, the character might not be shown and simulated in the game world yet. For now, it just resides somewhere in memory on the red client's computer.",
            "Of course, in our example, this same process is also happening for the client of the blue player. It needs to load the red player into its memory and is notified in the same way. However, we don't show the blue client in the example."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/3/4/f/0/f484f12467dbfe84f5057036d671200.png"
    },
    {
        "uuid": "91092904590718bcba1ec7fa68a1dd77634b6508",
        "index": 56,
        "imageURLs": [
            "https://media.preziusercontent.com/media/b/d/0/c/0/3a44d904223851bac9319a5b19b.png"
        ],
        "pageIndicators": {
            "current": "10",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Client OCS in-depth 4/5",
        "texts": [
            "Once the blue player moves even closer to the red player, the server notices this again. This time it sends the entire entity state of the blue player as a so called Entity Snapshot to the client.",
            "When the red client receives it, it is used to properly position and initialize the player character. At this point, both server and client have synced up the blue character, as both have the same state in memory.",
            "Note: The player client loads and receives state updates prior to when they would start moving into actual view on screen."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/7/0/0/7/642f3314060a3431edf8ddfaffd1200.png"
    },
    {
        "uuid": "bb3af9a24bd8ac9980e21f79967274c39929a350",
        "index": 57,
        "imageURLs": [
            "https://media.preziusercontent.com/media/a/b/b/6/b/938daf04b45b4525d10240315de.png"
        ],
        "pageIndicators": {
            "current": "11",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Client OCS in-depth 5/5",
        "texts": [
            "Since the Entity Snapshot syncs up the entity, the game server can send - on the next and subsequent game ticks - the entity state updates to the client, like it would have done in any traditional client-server architecture without OCS.",
            "This continues until one of the player exits the game or moves far away again and the object becomes irrelevant. Then the server stops sending entity state updates to reduce the CPU load and bandwidth. The server decides when to stop and resume networking for each individual client based on the network policies (like distance, object size and other more situational rule sets).",
            "Even if network updates were stopped once, entities can move in and out of 'networking distance' again multiple times. If the object didn't move too far away yet, then it might still reside in memory and doesn't have to be loaded again. A new Entity Snapshot is being send each time networking starts up again. But once an object is continuously networked the server only sends values which change based on the networking policies of the Serialized Variables software system."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/6/2/a/c/b06c3014e128f14935657c4da8f1200.png"
    },
    {
        "uuid": "bc761be07c242bb0f90aace8c578778e1c0b93f3",
        "index": 58,
        "pageIndicators": {
            "current": "12",
            "total": "12"
        },
        "title": "Client Object Container Streaming",
        "subtitle": "Summary",
        "texts": [
            "Client OCS now provides each client a partial view into the entire level on the server. The server has to lift the majority of the work by letting each client know which objects to load from its drive into memory so that the client CPU can start receiving the entity updates from the server and have entities stay in sync with the equivalent entity on the server. (Speculation: It is likely that the client itself decides when to unload objects from memory based on its available RAM capacity.) The server figures out when a client needs to load and receive state updates. Whenever that is the case, the server communicates that to the client. Therefore, Client OCS put some additional load onto the server, to allow for a significant computation reduction and performance on the client.",
            "This technology allowed CIG to improve performance for players significantly, because the amount of entities that had to be computed on the client was drastically reduced, thus the computation time for each game tick reduced. That also left the CPU with more time to help render more frames. The addition of multi-threaded loading and unloading of entities also reduced a ton of freezes and stutters. Client OCS allowed more objects like planets and their locations to be added into the Stanton solar system level (and more solar systems in general) without putting more load onto the player client."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/d/e/1/4/750ed37476f8acdbeaea07626901200.png"
    },
    {
        "uuid": "4dccfcc61e46985afc116112aa39093aa6eb1169",
        "index": 59
    },
    {
        "uuid": "6eb31f1f2481eea11d95aaf14969f1f16faf9122",
        "index": 60,
        "pageIndicators": {
            "current": "1",
            "total": "5"
        },
        "title": "Server Object Container Streaming (SOCS)",
        "subtitle": "Overview",
        "texts": [
            "With Client Object Container Streaming (COCS) we have improved the performance and memory requirements on the client side which improved the performance for the players noticeably. On the server, we can now increase the level size by adding more objects into the level, for example more areas like planets and locations without effecting the performance on the client as much as it did.",
            "Challenges:",
            "* the server still has to compute all entities and have all Object Containers loaded in memory",
            "* while adding more objects into the level does not effect the player client as much anymore, the server still has to load all and compute most of them, no matter if players are nearby or not",
            "* adding more and more objects into the level starts to exceed the server CPU and memory load which prevents us to create even larger levels with more content",
            "Solution: Server Object Container Streaming (sometimes Server Side OCS or SSOCS or SOCS)",
            "Goals:",
            "* Reduce the memory requirements on the server.",
            "* Reduce the load on the CPU on the server.",
            "* This is going to help performance later under Server Meshing, where multiple servers will simulate a game world, but don't have to load the entire game world and instead only their little corner section of it.",
            "Approach:",
            "* Dynamically stream game objects in and out of the level on the server while players are moving around",
            "* Serialize entities via Serialized Variables and stream/save/load entity data into and out of a database (pCache, later iCache) to free up memory, thus the server only has a portion of the entire database loaded",
            "* Thus only load the level areas where players are nearby to reduce the memory consumption",
            "* With certain areas of the level not loaded, the amount of entities that have to be computed on the CPU is being reduced and performance does not deteriorate on the server anymore"
        ],
        "sources": [
            "jp1",
            "cc2",
            "scl1",
            "s101",
            "s106",
            "pn38",
            "lc1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/b/e/4/a/5c395e041d6a2ede46184df6cd91200.png"
    },
    {
        "uuid": "c5cf9092b81d5c405141f5d85fa341447e69f29d",
        "index": 61,
        "imageURLs": [
            "https://media.preziusercontent.com/media/8/e/7/3/b/280705b4a6c854a7e5dbd2fb5e1.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "5"
        },
        "title": "Server Object Container Streaming",
        "subtitle": "Example - Initial Situation",
        "texts": [
            "With the implementation of Client OCS, we have reduced the memory and CPU load for the clients. However, the server still has to have all areas loaded into memory and all entities in those areas (like NPCs and players) computed each game tick, whether there are players in that area or not. That uses valuable memory and CPU computation time. This prevented the addition of new planets and locations since the server would exceed its memory capacity and CPU load.",
            "The idea to solve this is simple: Implement the same Object Container Streaming functionality for the server as well. That means: Only load those areas with players and unload all areas with no players.",
            "The difficulty here is, that the server defines the \"ground truth\", the universal state, for all the clients. Therefore, the server has to make sure that it has loaded all objects around players itself first, before being able to load and communicate state changes of those objects on/to the clients."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/9/8/2/a/a52cde04fc0965e0f8e539b5d8b1200.png"
    },
    {
        "uuid": "4a8c48732a7d2ad5fc2e0cf9d499c6d09930ecda",
        "index": 62,
        "imageURLs": [
            "https://media.preziusercontent.com/media/6/d/c/2/5/d4e8090457aa5ab0ab3b8d20718.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "5"
        },
        "title": "Server Object Container Streaming",
        "subtitle": "Example - The Solution",
        "texts": [
            "With Server OCS being implemented, the server too now only loads the areas with players in them. When players move around the level, the server dynamically loads the level in front of the player and unloads the level behind the player (if there are no other players in that area already/anymore, that is). CPU and memory loads are now reduced on the server, allowing more objects to be added into the level again. The server sends periodic queries to a database to check if objects around players are about to come into view. If that is the case the server will lookup the Object Container identifier of those objects and load the object into its memory.",
            "This technology allowed CIG to add more planets and moons of the Stanton system into the level which was previously impossible without exceeding the server resources.",
            "Unfortunately, Server OCS did not increase the player count of servers. Most computation intensive areas (like landing zones) were always populated by players and thus are usually never unloaded. Load was still high on the servers. Therefore, CIG had to decide between more players or more content. They went with more content."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/f/2/2/2/0699e2b40388ce7ae50402d3b801200.png"
    },
    {
        "uuid": "d2b3e69b14eff734561cb63e30e56c3e65567f25",
        "index": 63,
        "pageIndicators": {
            "current": "4",
            "total": "5"
        },
        "title": "Server Object Container Streaming",
        "subtitle": "Summary and Future Features 1/2",
        "texts": [
            "While Client OCS allowed clients to have a partial view into the level of the server, Server OCS now allows the server to have a partial view into the entire level. The entire level is now stored in a database on the server drive (and later into the large database at first pCache, then the new horizontally scalable EntityGraph).",
            "The server now does not have to load the entire level anymore, only select parts of it. Thus, even if the level size increases into hundreds of GBs (or even terabytes) in the database, it only needs to load a couple GB of it into memory at all times.",
            "Additionally, Server OCS will also be used for the Squadron 42 singleplayer game to load and unload objects on demand. A local database (EntityGraph) running on our computer along side the game, will act as the game save files by serializing the game objects from memory onto the drive and then loading it again from the drive into memory via Server OCS."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/c/d/f/8/7/bf5765f42279f23042e7a4a4e601200.png"
    },
    {
        "uuid": "a61b50fa06528dfb1cda657afa75fbf2d9b57941",
        "index": 64,
        "pageIndicators": {
            "current": "5",
            "total": "5"
        },
        "title": "Server Object Container Streaming",
        "subtitle": "Summary and Future Features 2/2",
        "texts": [
            "With the first version of Server OCS, whenever an area of a level is unloaded onto the drive/database, the entities in those areas wont be computed in the game loop anymore, thus no changes are occurring. Essentially, that specific section of the world is frozen in time until a player moves back into that area again. That is not ideal in a simulated, immersive and economy driven universe.",
            "To solve this, in the future, another server/service will take those unloaded areas and quickly simulate the time that has passed. This way, the computation resources required are greatly reduced by abstracting the simulation to a minimum. The universe would still appear alive. For example, NPCs who are busy repairing a ship wont have to be simulated running around and doing their job if no player is around to witness them doing it, only the ship hull values have to be increased in the database in the background. When a player enters the area again, the ship will be in a more repaired state compared to when the player left the area. Meanwhile, the NPCs are loaded back into the area again as if they were busy the entire time, even thought they did not actually exist to work on repairing the ship. This way, the entire universe will always feel alive, even thought most of the universe won't even be actively loaded and computed on the game servers themselves. This feature heavily relies on Global Persistence to be completed, since values have to be update in the database, then accessed and loaded into memory by the game servers. Simulating the game world on a higher abstraction level is also going to be the main functionality of the \"Quantum\" Economy Simulator.",
            "Another major future feature of Server OCS relying on Full Persistence as well will be Server Recovery. Once all states of all entities are continuously persisted into a database it becomes possible to recover a server after a crash. If a crash happens, a new server can be started in its place, the database provides the information about the entities that were present on the server at the time of the crash, load those entities back into memory via Server OCS and connect the player clients back to the server again. Therefore, in case of a server crash, players would only have to experience a couple seconds of interruption and barely any loss of progress in the game before being able to continue playing the game again where they left off."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/f/0/4/3/ec296fd4b5c8d54768fc8eecdc81200.png"
    },
    {
        "uuid": "03803a0251a06b80aed4f8e638d23f07da096aac",
        "index": 65
    },
    {
        "uuid": "ae9da52226c296a70377437874874ea47f0f4e2f",
        "index": 66,
        "pageIndicators": {
            "current": "1",
            "total": "10"
        },
        "title": "Persistent Entity Streaming (PES)",
        "subtitle": "Challenges:",
        "texts": [
            "* with eventually all items physically present and stored in the game world, with physicalized damage and degradation, with thousands of NPCs going about their lifes, with thousands of dynamic missions and events generated by AI and players, with a fully simulated economy, all in a single-shard server mesh, all of the game world needs to be persisted into databases and then accessed by the game servers in real-time, requiring an architecture that is able to handle high amounts of data",
            "Solution: Persistent Entity Streaming (sometimes just Persistent Streaming)",
            "Requirement for: Server Meshing, Full Persistence",
            "Goals:",
            "* have a persistent world where everything is stored into databases and loaded (streamed-in) by the game servers and various services that need that data",
            "* allow for all items to be placed anywhere in the game world and persisted over large amounts of time",
            "* split State Persistence and State Replication from the Game Simulation by moving that logic out of the game servers and into services",
            "Approach:",
            "* introduce a highly scalable, cloud-native service backend architecture for high data throughput, low latency, high responsiveness, fault tolerance and crash recovery.",
            "* besides new logic, this requires a lot of logic to be moved out of the game server and into their own services/servers.",
            "* introduce an horizontally scalable graph database (EntityGraph) and cache (Replication Layer) to store the state of the game world (entities). The game server is just left with simulating the game load partial data via Server OCS.",
            "* Its scalability spreads the load across multiple database servers and thus reduces the load on each individual database instance.",
            "* simulate the economy in a high-level abstraction environment to create a realistic action-reaction system. Its effects will be reflected in the game world by the game servers.",
            "* Implement logic on the game servers which (indirectly) access databases like Global Database (LTP), EntityGraph, Reputation database, Probability and Mission data generated by the Quantum Economy Simulator, etc. and then use all of this data to create their section of the game world with.",
            "* uses gRPC (Remote Procedure Calls) for communication between services.",
            "* this only comes fully online when the Hybrid/Replication Layer service goes live.",
            "* the initial persistence solution was attempted with a relational database which, after internal testing, didnt live up to perofrmance requirements, so a switch to a graph database was done end of 2020/early 2021",
            "* A first version comes online with Alpha 3.18, aiming for feature parity. Full Persistence will follow when more and more services come online, such as smart Matchmaking and proper Player Item Shard Transitions (or even Server Meshing with larger shards)."
        ],
        "sources": [
            "scl2",
            "cc2",
            "qa1",
            "lc1",
            "s117",
            "scr"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/0/d/2/1/467ac7147dda6e36dfd957587041200.png"
    },
    {
        "uuid": "aa485d22af52d23d1a62187df1a3f89afa1fc6ee",
        "index": 67,
        "pageIndicators": {
            "current": "2",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "EntityGraph & Global Database",
        "texts": [
            "The data of the game world(s) will be stored into two different database:",
            "EntityGraph database",
            "* This is the successor to the pCache database which was introduce when SSOCS came online.",
            "* EntityGraph was initially referred to as iCache.",
            "* EntityGraph is a sharded, horizontally scalable graph database.",
            "* It stores the entities which physically exist in the game world.",
            "* Referred to as 'unstowed items'.",
            "* This includes spawned ships, players, coffee cup, etc.",
            "* Each game world has its own EntityGraph database to store its unique state of the game world independently from other game worlds.",
            "* speculated: EntityGraph uses ArangoDB.",
            "Global Database",
            "* The Global Database is the successor to the Long Term Persistence (LTP) database which was introduced shortly after SSOCS came online.",
            "* It consists of three separate data collections:",
            "* Stowed Items",
            "* Wallet (aUEC)",
            "* Reputation",
            "* It stores the entities which are hidden away, only exist inside of inventories or are stored away (e.g. un-/despawned ships). Referred to as 'stowed items'.",
            "* There only exists one Global Database for all game worlds.",
            "* This allows ships and inventory contents to be accessible from every game world.",
            "* Even if players change to another game world, their stuff will still be available in that game world as well."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/c/7/9/2/a/2ebc80343d8991e7e8da4906c791200.png"
    },
    {
        "uuid": "012e1612b7842e58f51c4a47ffd7268b7f89da15",
        "index": 68,
        "imageURLs": [
            "https://media.preziusercontent.com/media/7/4/5/e/a/9c82b854636bb60eeaf08bab44d.png",
            "https://media.preziusercontent.com/media/6/a/e/a/e/aef21824370b0e9ceccb831fa00.png",
            "https://media.preziusercontent.com/media/c/5/0/1/e/76929ab4861bad2951b43fa5193.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "EntityGraph 1/3 - Graph database",
        "texts": [
            "EntityGraph is a graph database and is the successor and replacement for the pCache, introduced with Server OCS.",
            "Inside the graph database, game objects are represented as 'nodes'. Connections are made between nodes to symbolize a relation, also called 'edges' in the graph. A ship is a node and all entities inside - like players and any entities the ship consists of - would also be nodes and be connected to the ship via an edge. The two main strengths of a graph database is that each edge can further describe the relation between two nodes. It also allows for arbitrarily complex queries.",
            "This works perfectly with how Object Containers, Entity Hierarchies and the ZoneSystem work, as well as how this information has to be read and written. Adding, updating and removing nodes and edges are cheap database operations, which make up the majority of performed actions while simulating the game.",
            "When new entities are spawned, a new document containing the state of the entity is easily added into the graph. The same happens when items are unstowed from inventories. Likewise, while entities are moving around in the game world or interacting with one another, edges between nodes can easily be added and removed as well. This also happens when entities move from one zone into another."
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "ba9bb67483abd05a686524ca730a308228793f08",
        "index": 69,
        "imageURLs": [
            "https://media.preziusercontent.com/media/5/7/a/2/5/87848154507930bfcba305f81cc.png",
            "https://media.preziusercontent.com/media/b/5/3/5/0/8448e6c4fe0bf6b7895c1639f2a.png",
            "https://media.preziusercontent.com/media/8/0/2/d/0/321fecf414e955b8672a6bab324.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "EntityGraph 2/3 - Database Sharding 1/2",
        "texts": [
            "In terms of storage space, a single database might be able to store the entire universe data. But, in terms of processing power, when one day serving dozens or hundreds of game servers, it most definitely cant keep up. Too many read and write requests would hit a single database server. Just like game servers, databases have limited computing power. The solution? Splitting the data and thus distributing the load by horizontally scaling the database across multiple servers. Something similar will be done with the game servers under Server Meshing."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/8/7/0/4/067e847410f9dd295cd9c8047151200.png"
    },
    {
        "uuid": "649b6474ac6d505703d7c6564dc159d442f863ce",
        "index": 70,
        "imageURLs": [
            "https://media.preziusercontent.com/media/4/2/2/6/4/2deb93745ee84e93c62d007e69e.png",
            "https://media.preziusercontent.com/media/f/3/a/4/a/7779de94bacbb22fd4d0606b82a.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "EntityGraph 2/3 - Database Sharding 2/2",
        "texts": [
            "For example, the data of each planetary system could be its own database shard sitting on its own server. These sub-sets can be created through a sharding key and chunks. With these techniques, a router service is able to determine, in which sub-set and thus database shard a specific piece of data is being read from and written to. Therefore, the (also horizontally scalable) router service makes sure that the read and write requests reach the correct database shard. These router lookups are fast operations compared to the actual queries on the DB shards, so dont add a lot of latency.",
            "Speculated: The amount of sub-sets and thus database shards can change and scale automatically, depending on the load.",
            "EntityGraph uses the common 'Database Sharding' technique. Instead of one database server containing the entire data, the data is instead logically split into sub-sets. And each sub-set is then stored on its own database server, a Database Shard (Important Note: this has nothing to do with 'Game World Shards' which we will learn more about in the Server Meshing topics)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/b/2/c/e/1f17cb041b6a085cc46b550640c1200.png"
    },
    {
        "uuid": "0aab9dd5eabcd26a30eaed0974cab68baebcdb5f",
        "index": 71,
        "imageURLs": [
            "https://media.preziusercontent.com/media/7/9/0/4/e/cea97bc4042af759f1942a50abf.png"
        ],
        "pageIndicators": {
            "current": "6",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "EntityGraph 3/3 - Database Replication and Crash Recovery",
        "texts": [
            "But what would happen if one such database shard crashes or is not reachable? To minimize the loss of data and increase fault tolerance and service availability, EntityGraph also makes use of Database Replication. A data sub-set does not exist on just one database shard, but across additional database shards, which are called Replicas. With this, the same data exist on multiple database servers at once (also known as Data Redundancy).",
            "This enables database crash recovery functionality: If one database shard goes down, the other replica shards can still take over. A new database shard (or replica) can be spun up and the data can be copied/replicated back to this new one to ensure that there are always enough servers with copies of the data available and no data is ever lost. The replicas can also be used to read from, which makes the data available to more consumers.",
            "Going forward we will show and talk about EntityGraph as if it is just one database server. But remember, especially once game worlds are simulated by multiple game servers, that each game world will have its own EntityGraph, consisting of many database shards and router services. (Or - speculated - each game world has its own collection in one large EntityGraph database.)"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/c/4/5/3/6e5cdbf43d89649d79ab23c23d41200.png"
    },
    {
        "uuid": "430d3f25bbe216532573d041484502be75b74e8d",
        "index": 72,
        "pageIndicators": {
            "current": "7",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "Global Database 1/2 - Another database",
        "texts": [
            "Alongside the EntityGraph databases, there exist another database: The Global Database. But why another database? Why the need for two databases?",
            "The reason for this is that each game world has its own state. And this state is saved into its own EntityGraph database where all physicalized entities of that specific game world are saved into.",
            "In comparison, the Global Database allows specific data to be made available to all game worlds. Therefore there exists only one Global Database for all game worlds, in contrast to one EntityGraph database for each game world. This is required for player ships, all items on the player character or inventories in general, which should be available in the same state, independent on which server the player is currently playing on.",
            "The Global Database stores data related to Reputation, Currency (aUEC) and - most interesting here - Stowed Items. Items are interesting because they can be persisted in either the EntityGraph or the Global Database. We have a deeper look about items on the next slide."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/b/b/f/5/a522d8d45b3b9178c528e9689681200.png"
    },
    {
        "uuid": "377425eefafbd84b85bc7db0be3a0f1cc430eae9",
        "index": 73,
        "imageURLs": [
            "https://media.preziusercontent.com/media/7/a/0/9/0/97fee604350b7d297c3a90333a2.png"
        ],
        "pageIndicators": {
            "current": "8",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "Global Database 2/2 - Stow & Unstow",
        "texts": [
            "The Global Database and especially Stowed Items are important in the context of Persistent Streaming. Even though the goal is a single game world, a single shard, until Server Meshing provides the performance for this, there will still exist multiple game worlds in parallel. Therefore, initially players have to be able to move between game worlds, determined by matchmaking whenever they log-out and back in. In this case, the player items need to move with our player characters between game worlds. The Global Database enables this capability and makes our data accessible to all game worlds.",
            "The game now differentiates between stowed and unstowed items. When an items exist physicalized in the game world, it is an unstowed item and is stored in the EntityGraph database of that game world. When an item exists inside inventories or are un/despawned ships - and therefore only interactable from the UI - then they are considered stowed items and are stored in the Global Database instead.",
            "Therefore, whenever items are moved into an inventory, its node (e.g. Gun #9001 in the image) is removed from the EntityGraph database and a new entry is created into the Global Database (e.g. into the Inventory of Box #123). If an item is taken out of an inventory or a ship is spawned, then it is removed from the Global Database and a new node is created in the EntityGraph (an edge as well)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/0/a/5/e/2b4b5c44927b013a936e5e6338f1200.png"
    },
    {
        "uuid": "8b82ae9107d3ca80253d06e6f5688b561eb6aa34",
        "index": 74,
        "imageURLs": [
            "https://media.preziusercontent.com/media/d/2/e/e/8/c31284540758221e6dda47f4e77.png"
        ],
        "pageIndicators": {
            "current": "9",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "Hybrid service / Replication Layer",
        "texts": [
            "While a first cache (holding game world state) and the Global Database were able to come online in a first version in Alpha 3.15, the Persistent Streaming feature was not completed just yet. The Persistent Streaming feature is considered to come first online with the EntityGraph (and Replication Layer).",
            "We will talk more about the Replication Layer (sometimes called the Hybrid service) in a lot more depth in the upcoming Static Server Meshing topic. For now, all we need to know is, that it is a service that sits between the database, game servers and player clients. It will copy parts of the EntityGraph into its own memory (the in-memory cache that came online in 3.15) to coordinate the loading and networking processes.",
            "Initially, when it first comes online, there will only be a single game server connected to the Replication Layer. Only once it has been tested and considered to work, the number of game servers are slowly increased over the next subsequent patches, at which point Server Meshing starts to comes online.",
            "This shows that Persistent Entity Streaming and Server Meshing are two tightly coupled features and were developed alongside each other. We will go into more detail about the Hybrid service and the Server Meshing architecture as a whole in the next major topic."
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "1370340c2697f73a1409030389ecfb4bca77ec81",
        "index": 75,
        "pageIndicators": {
            "current": "10",
            "total": "10"
        },
        "title": "Persistent Streaming",
        "subtitle": "Service Migration & Economy Simulation",
        "texts": [
            "Last but not least, a lot of additional work was done toward Server Meshing in order to allow multiple game servers to share and access the same data of the game world. Many more services had to be created, some with entirely new functionality, others with existing logic which had to be moved out of the game server code into own services (e.g. the ATC logic responsible for having players and NPC request and being assigned a free hangar/landing pad).",
            "Similarly, data which is generated from the Economy Simulation will also be made accessible to all game worlds and game servers. And events within all game servers will be fed back into the Economy Simulation, to have all players effect each other, even if they are not all playing in the same game world."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/4/d/e/6/e/8a551b84a71bbd0ac765a7026041200.png"
    },
    {
        "uuid": "2492bb07989183e8f0a835163ab095d179be7e19",
        "index": 76
    },
    {
        "uuid": "daf7dac327c48799aba6502fe978315c50a130ab",
        "index": 77,
        "pageIndicators": {
            "current": "1",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Overview",
        "texts": [
            "After the first version of Client OCS was released, Server Meshing could finally be worked on/toward.",
            "Challenges:",
            "* the game server is still overloaded with the amount of players/entities, and adding more increases CPU load even more.",
            "* using better server hardware isnt a scalable enough option, so we need to make game servers horizontally scalable instead.",
            "Solution: Static Server Meshing, a first version and intermediate step toward the Dynamic Server Meshing implementation",
            "Goals:",
            "* make use of Distributed Computation to have multiple game servers compute the same game world by sharing the computational load.",
            "Approach:",
            "* introduce the concept of Entity Authority which allows the simulation load to be distributed/shared across multiple game servers:",
            "* each game server can now be assigned 'authority' over specific entities (meaning only that game server determines that entity's state).",
            "* a game server can now simulate just a subset of entities of a game world, instead of all entities by default.",
            "* introduce the feature of Authority Transfers where the authority over an entity can be seamlessly handed off from one game server to another. Note: While playing, players can only move between game servers of the same game world, not between different game worlds.",
            "* a new Hybrid service is introduced (which is also the cornerstone of Persistent Streaming):",
            "* connects to and coordinates the communication between clients, game servers and the EntityGraph databases.",
            "* relays entity state updates between clients and game servers.",
            "* determines which objects should be loaded via OCS on which clients and game servers.",
            "* also manages the Shard as a whole, starting up the game servers and connecting them to the Hybrid.",
            "* consists of multiple components: Replicant, Gateway, Atlas, Scribe. These will be turned into their own scalable services later.",
            "* New terminology specific to Server Meshing is introduced:",
            "* a game world that is simulated by multiple meshed game servers is referred to as a 'Shard' (a Game World Shard, not Database Shard!)",
            "* a game server is sometimes referred to as 'Server Node' as it is now part of a larger network/mesh.",
            "* For the static version of Server Meshing, limitations are set in place (which will be lifted under Dynamic Server Meshing):",
            "* the game world is spatially split into multiple sections and each game server is responsible/limited to simulating one such section.",
            "* these sections limit the area a game server can have authority over.",
            "* the area of these sections stays fixed/static, as well as the amount of game servers that compute the same game world stays fixed.",
            "* design for Server Meshing was changed end of 2020/early 2021 to utilize the Replication Layer (speculated: instead of direct server-to-server communication)"
        ],
        "sources": [
            "qa1",
            "cc2",
            "lc1",
            "cad1",
            "scr",
            "s201",
            "s202",
            "s203",
            "s204",
            "s205",
            "s206",
            "s207",
            "s208",
            "s209",
            "w11"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "512c7409c87be6c4d108c9c9658c74741ca42365",
        "index": 78,
        "imageURLs": [
            "https://media.preziusercontent.com/media/6/d/c/2/5/d4e8090457aa5ab0ab3b8d20718.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Introduction - Initial Situation",
        "texts": [
            "With the first versions of Object Container Streaming (OCS) for both client and server done, we are finally able to move onto the initial goal: Server Meshing. Even with the OCS software systems in place, it is not possible to increase the player count to thousand of players nor add tens of thousands of objects into the game world to make 100+ detailed solar systems a reality. A single game server alone is simply not powerful enough.",
            "Since the software technology that is Server Meshing is very complex, it is to be expected that it will take a long time to develop. To provide players a first version sooner, CIG decided to release a simpler, intermediate version of it first: Static Server Meshing.",
            "This should theoretically allow AI improvements, gameplay mechanics and more solar systems and locations as well as slightly higher player counts to be added to the game sooner, even before work on the final Dynamic Server Meshing implementation would be completed. We will talk more about the different versions shortly."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/6/f/b/7/3177dfe40a2abf6394a919d95ea1200.png"
    },
    {
        "uuid": "66270b2409952a15e5cf200cda2960cb032a5f01",
        "index": 79,
        "imageURLs": [
            "https://media.preziusercontent.com/media/0/0/3/d/b/11f28bc4fa28f06000794a2bee2.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "A simpler visual abstraction for game servers and clients",
        "texts": [
            "Since we are now entering the topic of Server Meshing, we need to represent the network connections of servers and clients in a more simplified fashion.",
            "The left half of the picture shows the server at the top and the connected players with their game clients at the bottom. Together they are forming a single Game World. There exist dozens of these Game Worlds independently from each at the same time. As before, the clients and servers are connected via a network (which in this case would be the internet) to allow information to be exchanged as data packets to have the server and clients stay synchronized.",
            "The right half the picture shows our new simplified version. We now represent the game servers as rectangles and player clients as circles. Since each server and client is unique, we will sometimes identify them with numbers (and colors in the case of the player clients)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/c/5/d/6/d2baed5455dbeb1c956888d21d61200.png"
    },
    {
        "uuid": "0f891085e629a79d8437b92182e70fa1cfe2c41d",
        "index": 80,
        "imageURLs": [
            "https://media.preziusercontent.com/media/3/e/2/3/7/b799efc4ed5a7c221fdbf6f47ad.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Introduction - Initial Situation",
        "texts": [
            "So far, each game world was simulated by a single game server (also sometimes called Dedicated Game Server or DGS). Furthermore, we can think of each Game World as its own \"Star Citizen universe\" with its own, independent state and happenings.",
            "We can think of all these game worlds/universes creating a \"multiverse\". We can see this multiverse in the image on the right. Each game world is computed by a single game server/DGS. (Clients connected to the DGS are not shown).",
            "The main downside is that each DGS currently simulates the entire game world and thus only supports a limited amount of entities, only up to 50 players and after some time ends up being under heavy load from all the loaded entities. Which makes player interactions and events rather rare and limited."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/1/3/d/f/edf41e747deaa6e72bbbb188f701200.png"
    },
    {
        "uuid": "a9472e69e1711ce11f4282cbd5af350ad3070784",
        "index": 81,
        "imageURLs": [
            "https://media.preziusercontent.com/media/7/6/c/6/7/8bd11c24f03a74b05113f98c8d9.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Endgoal of a Single Game World",
        "texts": [
            "Therefore, the end goal is to have all players in the same game world and thus can meet up, see and interact with each other freely. With only one game world, there would only be one universe and no \"multiverse\" anymore.",
            "This is going to be achieved by having all DGS compute the same game world. For this to work, different entities are be computed by different DGS. So each game server only has to simulate a small amount of entities instead of all entities in the game world. The game server that is responsible for simulating an entity is said to have authority over that entity. This authority can also be handed off between game servers.",
            "At the same time, the networking logic of Client OCS will make it possible for players on two different DGS to still see and interact with each other.",
            "Under Server Meshing, a game world is referred to as a Shard, a term coined by the MMO Ultima Online. Note: These are 'Game World Shards', not Database Shards (see the Persistent Streaming topic).",
            "However, while this is the end goal, for this single Shard/Game World to work it might require a very mature Dynamic Server Meshing implementation and capable lag compensation netcode. Until then - before all DGS are computing one and the same game world - we will have multiple intermediary versions of Server Meshing. In those versions, we will continue to have multiple game worlds (and thus still a multiverse)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/1/a/c/2/a885a6842c5b54ad1380af7d6ba1200.png"
    },
    {
        "uuid": "4b4e46dfbcec605b0fb72ae24343d578e988ee55",
        "index": 82,
        "imageURLs": [
            "https://media.preziusercontent.com/media/3/2/0/0/0/893c87d4b44868354e73ce6dd2c.png"
        ],
        "pageIndicators": {
            "current": "6",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Intermediate steps",
        "texts": [
            "Over time and across many patches, the amount of DGS/server nodes per Shard is going to to be increased. And in turn the number of entities (more locations with more items) and players per Shards can be increased as well. Fewer and fewer Shards will be required, until potentially - one day - a single Shard consists of enough DGS so that it can handle the load of all players (of a region/continent or world-wide).",
            "CIG likes to refer to their game servers - on which a game server executable/program runs - as a Dedicated Game Server (DGS). Under Server Meshing, they are also referred to as Server Nodes to highlight the meshed environment. We will use the terms game server, DGS and Server Node interchangeably as they mean the same thing. A server that simulates (a part of) the game world.",
            "However the difference - even in the intermediate Server Meshing versions - is that each game world is already being simulated by more than one game server. And DGS of the same Shard exchange entity state data with each other. With these network connections, the DGS are \"meshed\" together, forming a \"mesh network\" of DGS. The game servers end up being meshed: (Game) Server Meshing.",
            "Once a game world is computed by more than one DGS, we refer to that game world as a \"Shard\". This helps us differentiate the game worlds being simulated by multiple meshed DGS, from the game worlds running on a single DGS ('game world instances' vs 'game world shards'). Each Shard will still be its own SC universe, with its own Stanton, Pyro, Nyx, ect. but do share the same economy from the Quantum Simulator."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/2/c/a/9/b58d012496c95f3f874d31693ea1200.png"
    },
    {
        "uuid": "db611414e06f9c982fdd30f9a6af7198be42f88b",
        "index": 83,
        "imageURLs": [
            "https://media.preziusercontent.com/media/b/7/7/9/f/97c78424719b2b46eca81b90939.png"
        ],
        "pageIndicators": {
            "current": "7",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Shard Transitions vs Entity Authority & State Replication",
        "texts": [
            "There are going to be different types of transfers happening under Server Meshing.",
            "* Entity Authority Transfers will only be used within a Shard to pass authority beween two game servers of that Shard. That means authority can never be passed to a game server of a different shard. Remember that each game world has its own contained state of the game world and its own game servers that simulate only that state. An Authority Transfer means that another game server is responsible for simulating the entity. These authority transfers are happening infrequently and will be more frequent, once Shards are scaled with more game servers simulating different parts of the same game world.",
            "* (Player Item) Shard Transfers are transitions that happen across two shards. This can only happen while a player is not playing and will eventually be triggered by matchmaking when we are put into a different shard rather than the one we last played on (e.g. because we want to play with a friend on another shard). These Shard Transitions will become less and less frequent the larger shards are scaled, because players are more likely to play in the same Shard across multiple play sessions. Ideally (!) we would have just one Shard, so that no Shard Transfers are necessary.",
            "* There is also State Replication, which could be seen as a kind of transfer of entity state. Here, entity state is send to different machines, such as player clients, the EntityGraph database and other game servers (more on this later). Like Entity Authority Transfers, the replication of state occurs only within the same shard and is performed by the Replication Layer. Sending this state is very frequent and can happen multiple times a second, sometimes on each game tick. Serialized Variables and OCS optimize this."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/a/8/e/c/3cda44046ed879470faac0890d51200.png"
    },
    {
        "uuid": "966058d058c7d934d95c05448455d4de3009cee7",
        "index": 84,
        "pageIndicators": {
            "current": "8",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Major and Minor versions of Server Meshing",
        "texts": [
            "In the very first version of Server Meshing, each Game World (universe/Shard) will mostly likely only be computed by few game servers (server nodes). Mainly to be able to test the functionality in a simple and controlled environment.",
            "Afterwards, it will be increased to more and more server nodes across many patches. While there are going to be many of these gradual increases, there are going to be two major versions which Server Meshing can be categorized into:",
            "Static Server Meshing",
            "* A game world is going to be split manually into sections by the developers. Each section will be simulated by one game server/server node.",
            "* The name \"static\" means that these sections stay unchanged in their virtual size and amount (and thus also the amount of server node).",
            "* Server nodes (indirectly) exchange information whenever necessary, e.g. to allow for seamless transitions and interactions of entities, as well as server nodes exchanging entity state with each other where necessary (e.g. for collision checks).",
            "* There will still exist many Game Worlds/Shards along side each other, since not enough computing power will be available yet to fit all players into a single Game World/Shard.",
            "* A performance issue with this implementation exists: when all players of a Shard meet up in one section, then all have to be computed by one server node. Then that server node will be overloaded again, dropping in tick rate and negatively impacting the player experience.",
            "Dynamic Server Meshing",
            "* The game world wont be split into these sections anymore. Instead each game server is now able to follow a set of players wherever they go.",
            "* The name \"dynamic\" means that the amount of server nodes can increase and decrease. And that the entities a game server is responsible for simulating can be changed on-demand anytime rather than just at the border between sections.",
            "* All of this is done programmatically, meaning that - for each Shard - an algorithm is monitoring the performance on all server nodes and then tries to optimally distribute the load across the server nodes. More server nodes can be spun up or existing ones shutdown.",
            "* There will also be multiple minor versions of Dynamic Server Meshing, each increasing the number of server nodes per Shard, until eventually all players of a geographical region (EU; US, etc.) fit into one single regional Shard, maybe even all players world-wide into a single word-wide Shard."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/c/c/1/c/c/5ff827a48e6936b08ace43b48a91200.png"
    },
    {
        "uuid": "91cbbf5de064b5e8448cad8b0273d3bf9d7b4ef6",
        "index": 85,
        "imageURLs": [
            "https://media.preziusercontent.com/media/7/5/0/8/e/4d5a0984e939905e41a3445815d.png",
            "https://media.preziusercontent.com/media/b/4/e/e/3/06d6e124816b41be7fd4fc876dc.png"
        ],
        "pageIndicators": {
            "current": "9",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 1/8",
        "texts": [
            "Static Server Meshing splits the level into multiple sections to simulate each one on its own server. For example, the Stanton solar system could be split in half. Then two game servers could compute two planets each.",
            "In our example on the right, this split has been the green and red boxes. We only split the level into two sections, however Static Server Meshing could allow for dozens of sections (e.g. each of the major planets and each of their moons in the Stanton system on their their own server). However, this might be an inefficient use of servers since it could lead to a lot of empty or low load servers. Therefore, it initially will be divided in as few sections as possible for testing purposes, then slowly increased in numbers over subsequent patches.",
            "In our example, we split the game world into two sections, red and green.",
            "We are going to explore the concepts of Server Meshing by following the journey of the blue players which is about to travel from Microtech to Hurston."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/9/1/f/a/2/a266fc44835a2e530ab4d22d5df1200.png"
    },
    {
        "uuid": "556ed044a75959c3c4e3df810f08c6e310fca5e7",
        "index": 86,
        "imageURLs": [
            "https://media.preziusercontent.com/media/c/e/7/2/3/5568e6a4d9c85f63f911ad4d663.png"
        ],
        "pageIndicators": {
            "current": "10",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 2/8",
        "texts": [
            "In our example, we will have our three players again, just like we did in our previous examples for Client and Server OCS. The difference is that we now have two game servers instead of just one.",
            "We don't show the clients anymore, but remember that loading on the clients via Client OCS is still happening. We rather want to focus on how the game servers simulate and handoff entities between game servers (or 'server nodes' how they are also called under Server Meshing).",
            "We can see the split in the level by the green and red boxes. Players Red and Green are busy on the second game server (green box). Meanwhile, player Blue is loading cargo on the first game server (red box). We can see that the servers don't load the entire game world anymore - even if there are players - and instead only focus on their box/section. However, that might not be entirely accurate."
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "100452471dfca5b342430908c2d89fac5b861bb3",
        "index": 87,
        "imageURLs": [
            "https://media.preziusercontent.com/media/1/9/2/a/3/9aa9fb947b18d666e8dc4a62e77.png"
        ],
        "pageIndicators": {
            "current": "11",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 3/8",
        "texts": [
            "Speculated: To make server handoffs smooth and seamless, there might be an area at the border in which game servers overlap slightly where both servers load the same entities. Therefore, we have updated the boxes to also overlap.",
            "We also need to highlight which server computes which entities. For this reason, we now color the players by the color of the game server who currently is responsible for simulating it. Our blue player being computed by Server Node 1 turned red, and the other two players on Server Node 2 turn/stay green.",
            "When a game server simulates an entity, then we say that this game server has authority over the entity and its state. This feature is called Entity Authority and we will explore this in more depth in later slides.",
            "For now, let us see what happens, when the Blue player (now red to signify that game server 1 has authority and simulates it) is about to transport cargo from Microtech on Server S1 to Hurston on Server S2."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/7/d/f/c/e07d7f84c2681c1807463b87e741200.png"
    },
    {
        "uuid": "fcb323b5266eebb121f00616a33dd6de0646e930",
        "index": 88,
        "imageURLs": [
            "https://media.preziusercontent.com/media/8/0/1/5/5/2dd6a2740558df0742e58fe3a0e.png"
        ],
        "pageIndicators": {
            "current": "12",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 4/8",
        "texts": [
            "Once the blue player starts quantum traveling, Server OCS will continue loading and unloading the game world around the players. However, game servers are now limited, in what they can load and can have authority over, to their box. Once the Blue player closes in on the section/box of the server 2, the server will start to load the game world.",
            "This implies multiple game servers may have the same game objects loaded into their memory. Which is one of the requirements to ensure a smooth handoff.",
            "Speculated: How this is going to work exactly is still unclear. Even tho we show that game server 2 would gradually load the game world while the player approaches its section, it might be that a server only starts loading an area once the player entered its section."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/2/4/8/a/a8f47d143438dcc0995566cef921200.png"
    },
    {
        "uuid": "e82814bdb9350dc3d8fb1a8360d1c6c87e7e6e71",
        "index": 89,
        "imageURLs": [
            "https://media.preziusercontent.com/media/3/a/f/6/e/01cc7b7480fb564af8730bc2ccf.png"
        ],
        "pageIndicators": {
            "current": "13",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 5/8",
        "texts": [
            "The Blue player continues to travel through the level and now the player entity is in the overlapping section. Server OCS continues to do its job and now the player entity is loaded into the memory of both game servers.",
            "At this point, game server 1 starts sending entity state of the blue player to game server 2. This allows both servers to have the same/similar entity state. This is referred to as game server 2 receiving a 'client view' of the Blue player. This view is send via the new Hybrid service which we will learn more about soon.",
            "It is important to note that game server 1 still has authority over the Blue player. But it is in this overlapping area (or at the zone/box border) that authority can be handed off to another game server. When a handoff occurs, authority is taken away from game server 1 and given to game server 2. We will see on the next slide that the color of player Blue will turn green."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/c/0/a/8/5/6c144ba4de3b443f0544d167e3e1200.png"
    },
    {
        "uuid": "3ca1a08a1773d39e152bcccef7e50a19c2a8efca",
        "index": 90,
        "imageURLs": [
            "https://media.preziusercontent.com/media/7/6/7/f/4/407fd184bf68c95979d8760c542.png"
        ],
        "pageIndicators": {
            "current": "14",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 6/8",
        "texts": [
            "The Hybrid service is responsible for assigning authority to game servers and decides when authority is transferred between game servers. In the first version of Server Meshing, transfers will only happen in deep space somewhere between planets, but the dynamic versions it is supposed to happen anywhere anytime.",
            "Only one game server can have authority over an entity at a time, never more. However, other game servers can receive state updates of an entity which the game server with authority sends (more on this on the next slide).",
            "As we can see, authority of the Blue player was handed off to game server 2 and we changed to colors to green accordingly. Game server 1 does not simulate the Blue player anymore and instead receives the client view from game server 2."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/4/2/e/b/c/985e1744184980d573cc3c4be751200.png"
    },
    {
        "uuid": "dc5cbb596f1565f76f8edba588ab49a784b2013a",
        "index": 91,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/a/e/0/b/26b944c41dab5b49a6ebaeed575.png"
        ],
        "pageIndicators": {
            "current": "15",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "INTERMISSION: State Replication (Client Views for Game Servers)",
        "texts": [
            "When game servers overlap in the virtual space, they load the same entities into their memory. This is what Server OCS does. Since only one game server can have authority over the entity at any given point in time, the Hybrid/Replicant service can decide to send state updates to other game servers which do not have authority over that entity. This is the same or similar entity state data which the player clients receive. Which is why CIG initially explained it as \"client views for game servers\".",
            "This way game servers can let each other know whats up and keep entities synchronized on multiple game servers. This can then be used for those seamless authority transfers between the game servers.",
            "Speculated: For collision checks between two entities on different game servers there might have to be a consensus reached by the game servers or decided by the Hybrid/Replicant service."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/8/5/a/c/90f3d684c94a735860df3f52b951200.png"
    },
    {
        "uuid": "6207d630826afc24adbf1f7f47f1eaba9b79952d",
        "index": 92,
        "imageURLs": [
            "https://media.preziusercontent.com/media/b/7/7/3/2/b8fd9554c07b88e51c68a4b856d.png"
        ],
        "pageIndicators": {
            "current": "16",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 7/8",
        "texts": [
            "The Blue player continues their journey, now simulated by the second game server. Server OCS continues to load and unload the game world accordingly on both game servers. However, the decision making (what needs to be loaded) is not done by the game servers individually anymore and instead the Hybrid service figures out which Object Containers have to be loaded on which game server (and clients as well for Client OCS).",
            "For this, the Hybrid services/Replication Layer makes requests to the EntityGraph database and loads the game world - around the players - into its own memory cache. That is why we can think of the level shown on the left in our example as the Hybrid service. However, the Hybrid server does not simulate anything. That is the responsibility of the game servers. But we can think of the Hybrid service as having client views of all entities on the game servers."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/c/c/8/4/8c694fd400abf800451e20c1bf21200.png"
    },
    {
        "uuid": "7235a5ab3691c5f745556acea70f544d431e3fdc",
        "index": 93,
        "imageURLs": [
            "https://media.preziusercontent.com/media/3/4/2/2/5/325b61947dc944b5679c1ca686d.png"
        ],
        "pageIndicators": {
            "current": "17",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Entity Authority & Authority Transfers 8/8",
        "texts": [
            "In our example, the Blue player has now arrived at Hurston and starts selling his cargo for a profit.",
            "We notice that game server 1 now has no players in its section of the game world anymore while all players are on server 2 and have most of the locations loaded. This showcases the bottlenecks of Static Server Meshing very well:",
            "Empty of half full game servers are underutilized (costing as much to rent as game servers under full load), while game servers with too many players/entities can still end up being overloaded again.",
            "These downsides will be overcome with Dynamic Server Meshing, where game servers can be spun up and shutdown on-demand and where the green and red boxes do not exist anymore. There, this \"area limitation on Entity Authority\" - by assigning sections of the game world to specific game servers - wont exists anymore. Instead, authority will be much more fluid and game servers can follow its players and keep authority over them wherever they go. We will explore this in the Dynamic Server Meshing topic tho. For now lets have a deeper look at the Hybrid service."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/0/b/2/1/b85631a462f9841c985af6a540f1200.png"
    },
    {
        "uuid": "96aa6d7005471aa0b3a8b04ade5dd24ceeb2b0c7",
        "index": 94,
        "imageURLs": [
            "https://media.preziusercontent.com/media/b/1/6/e/f/2ff05f14c488f26d77170231082.png",
            "https://media.preziusercontent.com/media/2/c/f/f/1/126ad634679965cbe857c3d8303.png",
            "https://media.preziusercontent.com/media/6/9/e/d/c/bca111e4ed39c0d0c666064cbe2.png"
        ],
        "pageIndicators": {
            "current": "18",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Territories - Game World splitting via the ZoneSystem 1/2 (SPECULATED)",
        "texts": [
            "To understand Entity Authority and Authority Trasnfers some more, we also need to talk about \"Territories\". In order to be able to have different server nodes of a Shard compute different sections of the level, there needs to be logic that splits that Game World into these sections. These in-game sections are referred to as Territories. Splitting the Game World may make heavy use of the ZoneSystem (physics grids). It already splits the Game World into areas. Therefore, a Zone can be a room, spaceship interior, landing zone or even a planet/moon, planetary system or an entire solar system.",
            "Multiple Zones may be used to form the Territories. Thus one Territory could be considered a collection/group of Zones. All these Zones of a Territory and all entities within would be computed by exactly one DGS.",
            "Without Server Meshing, the entire Game World can be thought of to be just one single large Territory. The entire Game World is therefore computed by a single game server. This is shown in the images on the right, where all zones are marked with a red color. But once we can have multiple DGS (server nodes) working together, there will be many Territories in a single Game World (see next slide)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/e/9/9/b/20e75e94d44bd817b48d3e7cedb1200.png"
    },
    {
        "uuid": "e02fd0bb900dcdd68b3cf4298477a6002e471247",
        "index": 95,
        "imageURLs": [
            "https://media.preziusercontent.com/media/8/f/6/7/5/730afe34539bfb1e24b234f6968.png",
            "https://media.preziusercontent.com/media/b/8/1/0/7/1277eb744e3a3876cdaad0f2ecc.png",
            "https://media.preziusercontent.com/media/6/9/e/d/c/bca111e4ed39c0d0c666064cbe2.png"
        ],
        "pageIndicators": {
            "current": "19",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Territories - Game World splitting via the ZoneSystem 2/2 (SPECULATED)",
        "texts": [
            "As Zones can be nested (e.g. a landing zone on a planet or a vehicle inside a spaceship and the spaceship inside a hangar on a planet), a tree data structure of Zones emerges. Such a tree data structure can be split into multiple sub-trees.",
            "One such sub-tree could then be considered a Territory and thus computed by one server node. Sub-trees themselves can be further split or merged into more or fewer sub-trees and thus Territories. Especially in Dynamic Server Meshing, it's algorithm would then determine, which Zones are going to be part of which Territory, factoring in on the load in those Zones.",
            "More speculation: Therefore, the smallest Territory is going to be a single Zone, e.g. a single room inside a spaceship (unless individual entities like players also have their own zone). However, for certain situations, it might be necessary to spawn Zones dynamically (e.g. for a large space battles somewhere in space or on a planetary surface when a lot of players meet up in one place) to handle such loads specifically."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/9/e/a/c/32c4d254c988e3816b2959d5c421200.png"
    },
    {
        "uuid": "9856cbdbe159af63b8ac10251ae7a504e3ee5a47",
        "index": 96,
        "imageURLs": [
            "https://media.preziusercontent.com/media/1/4/a/7/a/7067a4442e9be66cd5896a60842.png"
        ],
        "pageIndicators": {
            "current": "20",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Humble Beginnings - The Hybrid Service 1/3",
        "texts": [
            "The Hybrid is a new service and the initial heart of Server Meshing.",
            "The Hybrid service sits between the game servers, player clients and the EntityGraph database of a Shard. It can be seen as the glue that connects everything together by coordinating and communicating between clients (represented as circles with a C), game servers (server nodes) and database.",
            "Initially, each Shard will have one such Hybrid service. The server nodes and player clients establish a network connection to the Hybrid to be able to send and receive data from it. The Hybrid will establish a connection to a EntityGraph database to request and store the state of the Game World.",
            "Using a mediator service like this - which sits between everything - makes it easier for the logic on the clients and servers as they don't have to be aware of where their data goes to or comes from. It all goes to the Hybrid first, which takes care to further relay it to the actual destination(s). Furthermore, each server node and client only needs to establish a single connection to the Hybrid, rather than every participant having a connections to all other participants of a shard. The Hybrid reducing the number of direct interactions and required decision making that would otherwise have been done on each game server.",
            "When the Hybrid first comes online, it will only feature a single server node to test it. Once this new infrastructure is working, more server nodes are added and Server Meshing comes online."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/9/7/d/9/797bb7944b3a68bf672ab5124361200.png"
    },
    {
        "uuid": "8cfb0f7f411a885ffb8ca136f73de3af99ed6355",
        "index": 97,
        "imageURLs": [
            "https://media.preziusercontent.com/media/9/0/c/e/1/fd46e3b41bab86246fb856f2a2f.png"
        ],
        "pageIndicators": {
            "current": "21",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Humble Beginnings - The Hybrid Service 2/3",
        "texts": [
            "The Hybrid service itself actually consists of multiple components, each one with its own functionality that is vital to bring Server Meshing online. The components that we know of so far are:",
            "* Atlas",
            "* Manages Entity Authority and Authority Transfers",
            "* Replicant",
            "* takes care of loading the game world on both client and servers",
            "* takes care of networking the game state for both clients and game servers",
            "* has the game state cached in its own memory, but does not simulate it, as that is the job of the game servers",
            "* Gateway",
            "* takes care of sending data from/to player clients",
            "* Scribe",
            "* Functionality still unknown. Database-related?",
            "This is just a quick overview. These services have been talked about in lots more detail in their own Minor Tech slides. But, we are still going to drill down on the Replicant and Gateway components, as these play key roles in Server Meshing.",
            "More types of services have been teased but not elaborated on yet."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/a/b/3/0/ab6d2aa4452b8aef2437697a51a1200.png"
    },
    {
        "uuid": "f0cdb36abf0cd534066d4014a55f5d9ae0e00fd2",
        "index": 98,
        "imageURLs": [
            "https://media.preziusercontent.com/media/9/0/c/e/1/fd46e3b41bab86246fb856f2a2f.png"
        ],
        "pageIndicators": {
            "current": "22",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Humble Beginnings - The Hybrid Service 3/3",
        "texts": [
            "However, the plan is to eventually move all these components out of the Hybrid to have them be their own services, running on their own servers. Once all components have been taken out, the obsolete Hybrid service will then be removed. This work is done when working on/toward Dynamic Server Meshing, after Static Server Meshing has released.",
            "The individual service types are going to be horizontally scalable, meaning that multiple Replicant services could be running alongside each other. This is how Server Meshing is planned to be scaled up to support many more entities and players.",
            "But - because the Shards for the very first versions of Server Meshing are still going to be very small (few server nodes and player clients) - a need for many services is not there yet. To bring Server Meshing online, have its functionality tested and made robust, a smaller, more manageable environment with a single Hybrid service is much more suitable. The infrastructure complexity and its overhead is minimal and the focus can be on maturing the functionality itself. Once that is working fine, the components will be turned into services and scaled up."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/d/4/5/d/c/b25b7d546f299d83cc67135aa3c1200.png"
    },
    {
        "uuid": "be75aae7e3c9ac2d60b94b876568fbf356869dc7",
        "index": 99,
        "pageIndicators": {
            "current": "23",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Replicant & Gateway 1/4 - The Deeper Look",
        "texts": [
            "The Replicant & Gateway are components of the Hybrid service.",
            "Not all of their code is new. Parts of their functionality already exist as OCS functionality. OCS had already introduced various logic to load Object Containers on both clients and servers, as well as optimized the networking by only sending entity states to the individual player clients that need it. For Server Meshing, most of that OCS logic is moved into the Hybrid service as part of the Replicant and Gateway components.",
            "Player Clients and Game Servers wont connect directly anymore. Instead Game Servers are connecting themselves to the Replicant, while the Player clients connect themselves to the Gateway."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/f/b/3/e/b99e9a6499c8362e4d2962fe2521200.png"
    },
    {
        "uuid": "31fc961b1c7938654384ff92afb1a7a4e37762bc",
        "index": 100,
        "imageURLs": [
            "https://media.preziusercontent.com/media/4/1/1/2/d/bc3101648b0a1082b041561acf1.png"
        ],
        "pageIndicators": {
            "current": "24",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Replicant & Gateway 2/4 - Object Container loading",
        "texts": [
            "The Replicant & Gateway include what could be considered the decision making logic of OCS. Mainly functionality of Network/Entity Bind Culling and Serialized Variables Culling that were introduced as part of Client OCS. If we remember, these were responsible for",
            "* determining which Object Container to load on both the clients and on the game server",
            "* determining which entity state updates have to be send to which player client",
            "Note: The loading logic of OCS that actually load & unload the entities into memory via Object Containers are still on the server nodes and player clients.",
            "In the image below we can see the Network/Entity Bind Culling functionality in action. Previously, under OCS, the game server determined which Object Containers it had to load. After the game server had successfully loaded these Object Containers, it then told (some of) the player clients to load those Object Containers as well. Under Server Meshing, the Replicant is going to take over this part for the clients AND game servers. This has the benefit that Object Containers can be loaded on clients and servers in parallel (came online with Alpha 3.17). They dont have to load on the game server first anymore before the client is notified (which was a bottleneck without the Replicant)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/d/b/7/b/5b454c14a1d816bc3e173ffa8891200.png"
    },
    {
        "uuid": "16ae47238cca974e4690ea0ede014d72eeb05923",
        "index": 101,
        "imageURLs": [
            "https://media.preziusercontent.com/media/a/0/2/5/c/778eebf4270b2ba4500deb86cb3.png"
        ],
        "pageIndicators": {
            "current": "25",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Replicant & Gateway 3/4 - Entity State Network Replication",
        "texts": [
            "The entity state updates from server nodes are send to select clients and other server nodes of the Shard. This was previously determined by Serialized Variable Culling (part of OCS) in the game server logic, but now done by the Replicant service.",
            "Note: How and where exactly the decision is being made (Replicant and/or Gateway) was not clear to me. But we do know that the Replicant is copying parts of the EntityGraph database into its own memory - to cache entity states for quick read and writes, to know about the position of all entities. We also know that the Gateway is supposed to be a very lightweight.",
            "Speculated: Therefore, the Replicant might already be determining to which client(s) it has to be send and the Gateway just replicates and sends the data to the correct clients.",
            "This allows players to receive entity state updates from multiple server nodes. This enables players to look into multiple server nodes and see entities and other players that are computed on other server nodes. This is also used when two server nodes have to sync up entities for a authority transfer/handoff when entities are about to cross from one Territory to the other.",
            "The Replicant will update the data in its own in-memory cache with the data which was send from the server nodes (with authority) and persist these changes back to the EntityGraph database."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/4/9/b/c/22930d944ee9e4e36395295ab871200.png"
    },
    {
        "uuid": "cdf18b8aa26c30d29ad7d571f7570c1ea4693bb2",
        "index": 102,
        "imageURLs": [
            "https://media.preziusercontent.com/media/a/f/2/8/d/58322434da2acbe5e13d81f4c39.png"
        ],
        "pageIndicators": {
            "current": "26",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Replicant & Gateway 4/4 - Player Action Network Replication",
        "texts": [
            "In a similar fashion, the clients send their actions to Gateway which will relay those to the Replicant. And those Replicants will relay it to the correct server nodes that require this information.",
            "Speculate: It might be that the Gateway service also relays client actions directly to other clients, and not just to the Replicants. This would mean that player actions might end up on each others screen quicker. This would minimize latency until the verification from the server nodes would arrive, which in this case would follow shortly after (if the server node disagreed then the client will have to make rollbacks and adjust the entity state). This might be especially useful in a world-wide shard where the latency to the server node in another datacenter might be higher."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/b/0/8/a/e3f941f41f9a2851e201c79cbb81200.png"
    },
    {
        "uuid": "31397b0092c57962dcdaf4e06afee4de1cd64ca1",
        "index": 103,
        "imageURLs": [
            "https://media.preziusercontent.com/media/0/b/1/2/d/9d6a411462c885eb4b0b4116fc6.png"
        ],
        "pageIndicators": {
            "current": "27",
            "total": "27"
        },
        "title": "Static Server Meshing",
        "subtitle": "Clients partially looking into multiple server nodes",
        "texts": [
            "All entities in the game world are persisted in the EntityGraph database which can be accessed by the Hybrid service (Replication Layer or Replicant).",
            "The image on the right visualizes OCS and Server Meshing very well. Specifically how the individual game servers are partially loading and simulating parts of the entire game world with the help of Server OCS. As well as how the player clients looking partially into one or multiple game servers via Client OCS."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/d/a/b/a/f6088d940e38d365b9549c13e3f1200.png"
    },
    {
        "uuid": "521d71e281b3f43a5c895ca553124fda39d7b46c",
        "index": 104
    },
    {
        "uuid": "2930cb3b4d3e7fd88c62527b3b256154ed8f591c",
        "index": 105,
        "pageIndicators": {
            "current": "1",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Overview",
        "texts": [
            "With splitting the game world and its simulation with Entity Authority, the next step is to make this solution dynamic for better scalability. (Disclaimer: Many details about Dynamic Server Meshing are still unclear!)",
            "Challenges:",
            "* while the individual servers are now less likely to hit their memory and CPU load capacities, the issue of too many players being in the same section of the game world, and thus on the same game server, still exists",
            "* one solution would be to make the sections of all game servers very small, so that each one only has very few locations and spaces to compute. However, this increases server expenses and potentially to a lot of unoptimally used servers.",
            "Solution: Dynamic Server Meshing",
            "Goals:",
            "* allow for (theoretically) unlimited player and entity count in a Shard (at least on the server-side, but not client-side)",
            "* ideally, allow all players to play in one single Shard (either one Shard per region and/or even a single world-wide Shard)",
            "Approach:",
            "* The Entity Authority limitation for the game servers - game servers always responsible for a section of the game world - is lifted.",
            "* Instead game servers follow their 'authorized' players freely while those travel through the game world.",
            "* Game servers can now overlap, exchange 'client views' with each other and transfer authority anywhere in the game world.",
            "* New functionality is introduced as well:",
            "* An algorithm/heuristic is introduced, which continuously monitors the computational load in the game world and decides for an optimal distribution of the computational resources (servers), by moving entities and their authority from an overloaded game servers to a underutilized game server.",
            "* Whenever a Shard becomes too crowded/overloaded, an additional game server is spun up to provide more computational power. Likewise, game servers can be shutdown, if there is not much load. Less servers rented, more cost-efficient Shards."
        ],
        "sources": [
            "rtv1",
            "s204"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/8/7/2/7/1da4ad342f584b3d1598f2320a11200.png"
    },
    {
        "uuid": "a7f8c9efacf4674461770f808106738ce7a40193",
        "index": 106,
        "imageURLs": [
            "https://media.preziusercontent.com/media/5/4/c/a/7/1e9f21b409aa0bfb15c8d5bc9ec.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Free roaming of entities",
        "texts": [
            "Under Dynamic Server Meshing, most of the logic of Static Server Meshing will stay intact. It is merely iterated upon and improved to be able to achieve larger Shards with more players and entities in it, while also managing the real world economical side of renting just the necessary/optimal amount of game servers. This is done by scaling the number of server nodes and other services (Replicants and Gateway services) to the optimal amount.",
            "The big difference between Static and Dynamic SM is that, the limitation we previously had on the game servers. This limitation is now lifted and thus they are not assigned a specific section of the game world anymore. For this reason we have removed the red and green boxes in the image below. The functionalities of Entity Authority, 'client views' between game servers and Authority Transfers still exist and are utilized."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/7/8/7/a/53312bf45fc9c0ab36f3e0bf2b41200.png"
    },
    {
        "uuid": "0c470c339e6aeb0b0950357f7edd83a8d7476515",
        "index": 107,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/c/d/d/f/b7c36694ca0812ce4fb726f0a37.png",
            "https://media.preziusercontent.com/media/d/b/0/f/7/fe7400647b4bf145506185755ba.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Free roaming of entities",
        "texts": [
            "Without these sections, game servers are now able to load any part of the game world - but still limited to those around their authorized player - and have authority over certain entities within those loaded areas. They will follow their players - over which they have authority over - and load the game world wherever they travel to.",
            "In this case, the green players spread out in the level and their game server followed them."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/a/9/8/8/e5b3bda44f385945c2a7410f7441200.png"
    },
    {
        "uuid": "ca5a3448afe2ffd9fd1e9e94b0466b09b3f5021e",
        "index": 108,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/0/a/f/f/c3758d240d780335d003528ebe4.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Free roaming of entities",
        "texts": [
            "When players from different game servers meet up in the same location and the game servers overlap, then they will load all entities in that area and start exchanging 'client views' with each other. Like they did at the section overlaps under Static Server Meshing."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/a/3/5/9/7bae0ad4e6f96b5ea080bf030211200.png"
    },
    {
        "uuid": "86e0a269c9c1f79fbbd39686c3e7a15458c51810",
        "index": 109,
        "imageURLs": [
            "https://media.preziusercontent.com/media/0/a/7/4/5/1844ae44ad3a5e5d777bd3ed35c.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Free roaming of entities",
        "texts": [
            "At this point, authority might be handed off anytime to one of the game servers. But it could also be decided that these players stay on their game servers, so it is also very possible that players stay on their assigned game server throughout their whole play session.",
            "Maybe, most of the time, only interacting entities need to be moved onto the same game server (for example reduce server-to-server communication, the need for consensus techniques and ultimately to reduce computational load and save on game servers). For example, entities that travel past each other (like while flying, especially in Quantum Travel) do not need to be moved onto the same game server."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/f/c/7/b/dbd7ce84e989cd8558ffcd3277a1200.png"
    },
    {
        "uuid": "7fe9598ea645e9674d1261b3a5f3b048fb0aab9d",
        "index": 110,
        "imageURLs": [
            "https://media.preziusercontent.com/media/3/d/2/4/4/d9316104190849bc3a121ec4858.png"
        ],
        "pageIndicators": {
            "current": "6",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Free roaming of entities",
        "texts": [
            "When more players are joining the Shard, or there is more activity and load happening (like a spacebattle), then more game servers can be spun up and connected to the Shard.",
            "Likewise, in the case where a game server crashes, a new one can be spun up, load the entities again and continue the simulation again with only minor disruption to gameplay."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/0/3/1/5/3/60c58ab41a1a47873a51362afea1200.png"
    },
    {
        "uuid": "6616530bf7dc3398b490bbe5089e675d6df96e19",
        "index": 111,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/2/2/5/9/9ccd3294ba1b4d07f8870db166a.png"
        ],
        "pageIndicators": {
            "current": "7",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Free roaming of entities",
        "texts": [
            "As mentioned, the load will be continuously monitored to try to have a smooth player experience and an economically optimal amount of game server used. Entities of underutilised game servers might be moved to another game server and so that those game servers can be shutdown down. In our example, the green players/entities of server node 2 were moved to server node 3 (blue)."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/2/0/5/7/e/ab8cbc742868cf45db05664cd1e1200.png"
    },
    {
        "uuid": "e8007ffe90569d906728f65784367b8ed14a9137",
        "index": 112,
        "imageURLs": [
            "https://media.preziusercontent.com/media/f/a/d/2/c/4e467574811afd71ed9d26380e1.png"
        ],
        "pageIndicators": {
            "current": "8",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Horizontally Scalable Architecture",
        "texts": [
            "For Dynamic Server Meshing, the individual components of the Hybrid services will be split out into their own services. For example, the Replicant & Gateway were components of the Hybrid service, but are then individual service, of which there can be multiple running alongside each other to share the load across.",
            "Player Clients and Game Servers wont connect to the Hybrid service anymore. Instead Server Nodes are connecting themselves to a Replicant service, while the Player clients connect themselves to a Gateway service (note: if connected to only one or multiple is not known yet).",
            "Each Gateway service establishes connections to one or more Replicant services. All of these connections are mostly likely managed by another service (Atlas?), since service, game servers and connections have to be added and removed on-demand.",
            "More types of services have been teased but not elaborated on yet.",
            "The name \"Replication\" stems from data being copied/replicated. \"Layer\" suggests that the data is passed through a layer before reaching its actual destinations (clients, server nodes and/or the EntityGraph database). A data packet is received, replicated, then send out to multiple, different computers/consumers.",
            "How many Gateways, Replicants and Server Nodes are required is not known yet. The image shown might not be accurate, it just tries to visualize the general idea."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/a/e/f/b/dfdf2724c43973972000ec45e1d1200.png"
    },
    {
        "uuid": "7ec5271f226e67abe3f2e84e01721e2be938d14d",
        "index": 113,
        "imageURLs": [
            "https://media.preziusercontent.com/media/f/9/f/2/e/6e8ecb4479094cec4a5e77e216c.png",
            "https://media.preziusercontent.com/media/f/a/d/2/c/4e467574811afd71ed9d26380e1.png"
        ],
        "pageIndicators": {
            "current": "9",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Multiple Shards",
        "texts": [
            "Multiple Shards can independently exists at the same time alongside each other (the multiverse). Players can only play in one shard and thus can not see what happens in other shards. Certain data still has to be made available to all Shards tho. This data is stored in the Global Database that exists outside the Shard environments. It also make it possible to let players switch between shards.",
            "So far, we have talked about how the Server Meshing functionality is built up and how the individual services, layers and the overall architecture emerge from it. It is important to note that each Shard consists of one such architecture. Each Shard will have its own Gateway, Replicant, Scribe and Atlas services, as well as its own server nodes, clients and Entity Graph database."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/f/f/f/d/1168e354d388f73ff37d814646c1200.png"
    },
    {
        "uuid": "5af8e64d6d4f44ea119c2474e003aacf051fb572",
        "index": 114,
        "pageIndicators": {
            "current": "10",
            "total": "10"
        },
        "title": "Dynamic Server Meshing",
        "subtitle": "Services and Databases",
        "texts": [
            "With this system we can dynamically scale the universe based on the current activities in the game world. Other services and databases like the \"Quantum\" Economy Simulation, Dynamic Mission System, Item Cache, Account Database, etc. will be accessible to all game servers.",
            "Ideally, all of these services will be designed in a way that allows them to be horizontally scaled, meaning they can be copied and distributed onto more than one data center. Or they all receive their own cache layer. To achieve a good performance, databases have to be replicated onto multiple data centers across the globe for all game server to have quick access. This also enables redundancy, basically the data is present in multiple identical databases, which in case of a database crash, a new database can quickly be spun up in its place by replicating the data from one of the other, still running databases. This might allow for one single world-wide instance where all players from around the world are able to play together without major interruptions and lag since there will always be a database server near a game server.",
            "Theoretically, with later versions of Dynamic Server Meshing, game servers and Replicant and Gateway services could be geographically re-positioned on-the-fly to another data center where the latency of the currently connected players is the most similar to create a fair playing field for all players by reducing the chance of issues like peekers advantage from occurring. In general, as long as latency is stable and there is not a lot of jitter, code systems like lag compensation can guarantee a smooth and fair player experience even with higher latency to servers."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/2/7/a/e/d/17ea5ad4eebac8564f4e548a0e51200.png"
    },
    {
        "uuid": "d07a35ac7365d7e69356c91dbd279f8d8b969281",
        "index": 115
    },
    {
        "uuid": "2e4b5d1e3024a0e83232d1b97f92603102a2f1cf",
        "index": 116,
        "pageIndicators": {
            "current": "1",
            "total": "6"
        },
        "title": "Single Shard",
        "subtitle": "Overview",
        "texts": [
            "Even if a first Dynamic Server Meshing has been released, there is still more work left to be done to have it scale up and make a single shard possible.",
            "Challenges:",
            "* the early versions of Server Meshing wont be powerful enough just yet to allow all players to play in the same game world; we will continue to play in a multiverse, albeit less and less over time as shards grow in terms of how many players can support",
            "Solution: Single Shard",
            "Goals:",
            "* have all players of a region or worldwide play in the same game world",
            "* gradually/iteratively improve and scale up Server Meshing until a single shard universe is possible",
            "Approach:",
            "* scale up the amount of servers per Shards high enough so that all players can fit into a single shard.",
            "* The first milestone/goal is going to be one shard per region (all players from US play on their own single shard, all players from EU play on their own single shard, etc.)",
            "* The final goal is offering a world-wide shard",
            "* This will require further R&D on how to reduce the impact of high cross-region latency",
            "* For scenarios where areas have extremely high population, a layering technique might be introduced that puts interacting players into their own layer.",
            "* Speculated: There might be a time period where CIG will offer one shard per region as well as one world-wide shard. For the developers, this would provide a testbed for global shard tech, while offering the players a choice between an experimental experience in the global shard and a more stable one in the regional ones."
        ],
        "sources": [
            "tw1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/7/2/9/b/cbdc73a48a9863fec0b4f2299bf1200.png"
    },
    {
        "uuid": "33e58f1aca6cdc8d06305c8376eb86410618daa1",
        "index": 117,
        "imageURLs": [
            "https://media.preziusercontent.com/media/5/d/e/3/5/c49be014c2d9fb3c52ea7712fcc.png"
        ],
        "pageIndicators": {
            "current": "2",
            "total": "6"
        },
        "title": "Single Shard",
        "subtitle": "From Multiple Shards to Single Shard 1/4 - Static Server Meshing",
        "texts": [
            "Initially- under static server meshing - all shards will be statically meshed. That means multiple, small and equally sized shards. Each region will have its own shards. Even tho the individual shards are statically meshed, the number of shards can still change. For example, a new shard is spun up whenever more players login and want to play and all other shards are already full."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/8/7/3/f/0649be641f0ac9ec2f1b6b9c7e21200.png"
    },
    {
        "uuid": "57a18982ec9c0c76da51381b7848973c62e03d2b",
        "index": 118,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/e/f/e/e/6237e514964b57029df8cdc405c.png"
        ],
        "pageIndicators": {
            "current": "3",
            "total": "6"
        },
        "title": "Single Shard",
        "subtitle": "From Multiple Shards to Single Shard 2/4 - Dynamic Server Meshing",
        "texts": [
            "Once we have Dynamic Server Meshing online, shards start to be come larger and can end up being of different sizes, depending on the amount of players/entities and activity inside them. Each region will still have multiple shards."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/f/0/c/2/d9ff8f64af7ba06b6cfb44751ff1200.png"
    },
    {
        "uuid": "cd554b5e999bfd6d6e694222cfbe5d0dde91d731",
        "index": 119,
        "imageURLs": [
            "https://media.preziusercontent.com/media/6/d/7/3/0/8bbc7834f469f55e6d241255b0c.png"
        ],
        "pageIndicators": {
            "current": "4",
            "total": "6"
        },
        "title": "Single Shard",
        "subtitle": "From Multiple Shards to Single Shard 3/4- Regional Single Shards",
        "texts": [
            "Once Dynamic Server Meshing becomes powerful enough to support all players of a region, we will have Single Regional Shards. All players of a region will be playing in the same game world."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/7/7/8/d/2a74d904893a6ac4bcc6ba562d21200.png"
    },
    {
        "uuid": "35c5af7fd28c93a55c233f33db22679050330104",
        "index": 120,
        "imageURLs": [
            "https://media.preziusercontent.com/media/8/5/a/6/9/0e287494b0aa5b968eb80f4e9e6.png"
        ],
        "pageIndicators": {
            "current": "5",
            "total": "6"
        },
        "title": "Single Shard",
        "subtitle": "From Multiple Shards to Single Shard 4/4 - World Wide Shard",
        "texts": [
            "Once Single Regional Shards are possible, work can begin on improving the latency compensation techniques. Those reduce perceived effects of latency for the players when playing across regions where latencies of over 200ms are possible. Further R&D is required for this. If it is possible and enjoyable, then all players play in a Single Worldwide Shard.",
            "Speculated: CIG might start offering an optional 'Worldwide Region' that will run alongside the existing regions, so players can choose between the regional and the worldwide shard. And maybe some day, the tech becomes capable enough where only the world-wide shard remains and the regional ones are removed."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/9/d/3/5/aaa8f12484ab10bb0e86ac8d13e1200.png"
    },
    {
        "uuid": "5bfa74195a64b39d1eaf08bffb94b663f9f12fbf",
        "index": 121,
        "pageIndicators": {
            "current": "6",
            "total": "6"
        },
        "title": "Single Shards",
        "subtitle": "Remaining Technical Limitations: Player Client = The Final Frontier",
        "texts": [
            "One final technical hurdle, that might not be completely overcome without some additional tricks and workarounds in the end, will be the rare scenario where thousands of players/entities are very close to each other and thus directly visible to the player client (like on a large flat surface on a planet). Even tho the game servers might be fine, the CPU/GPU computation on the player client might exceed its limits, resulting in dropping performance.",
            "One way to push performance on the client would be to skip network updates and simulation for further away objects to reduce the network bandwidth (Entity Component Update Scheduler can be improved to enable this). In terms of rendering, using the same, low level LOD asset for all far away player characters and vehicles would help with the rendering performance on the GPU (which may look worse but would still give the sense of a large, active crowd). But depending on the size of the crowd and the amount of objects, the experience might still not be great.",
            "A drastic but simple workaround would be to limit the amount of objects to a small radius around the player (leading objects to pop-in and pop-out of existence in the distance), lookdown certain game areas via game mechanics (close jumppoints, NPC blockade, et.) or to create layers (parallel instances?) of the same area, taking into account friend and foe of players, but both of these solutions would have severe implications for gameplay that would need to be worked around.",
            "Anyways, in case of such a rare edge case scenario, this quickly goes into the realm of major speculation with lots of possible solutions, so I guess we will leave it here and know more once that point is reached. For the overwhelming majority of situations in the game, the system of Dynamic Server Meshing is expected to perform very well, because other players and objects will be hidden inside buildings and ships and therefore can be hidden from the player client and reduce memory, CPU and GPU load to feasible levels without the need of workarounds."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/7/0/a/2/2/dbfd1df4fc2a852d4f4142da5f31200.png"
    },
    {
        "uuid": "f4c5a9cb3342f61a579551a2d91a97e27a80cd20",
        "index": 122,
        "pageIndicators": {
            "current": "1",
            "total": "2"
        },
        "title": "Road to Dynamic Server Meshing",
        "subtitle": "Conclusion",
        "texts": [
            "This concludes our journey to Dynamic Server Meshing. So what did we learn today?",
            "Object Containers: Splits the entire level into individual, reusable level building blocks aka Object Containers.",
            "Client OCS: Allows clients to only load and network the nearby level area by being provided a partial view into the server's level.",
            "Server OCS: Allows the game server to only load level areas with players inside by being able to load and unload objects into a database. Essentially the game server has a partial view into the entire level which resides in the database.",
            "Static Server Meshing: Splits the level into a fixed number of sections and computes each one on its own game server. Players are seamlessly transferred between servers when traveling between these sections. Players can look into multiple servers/sections at the same time.",
            "Dynamic Server Meshing: The servers are not fixed to a specific sections of the game world anymore and instead are able to follow their players wherever they go. Game servers can be spun up and down whenever the load demands it.",
            "If you made it this far, I hope that this presentation was able to provide a good overview and a new appreciation for these technologies. As we can see, a lot of work has already been completed and we are getting ever closer to Dynamic Server Meshing for Star Citizen being a reality. Even after the release of Dynamic Server Meshing, all these software systems we talked about will most likely be continuously maintained, iterated over and optimized over many years to keep improving on the player experience and allow for larger Shards.",
            "While this is the end of the major tech explanations, there is still much more information about each of the minor and related technologies left to check out. Feel free to keep on reading! And let me know if you found this overview helpful :)",
            "Also don't forget to check out the sources at the end of the presentation with all the information for yourself!",
            "And a big thanks goes to the developers at CIG for working on these software systems to make Star Citizen a reality!"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/2/2/1/3/8/346b631480a9eafd67af783d1a81200.png"
    },
    {
        "uuid": "c88611ef170030cefdb7bb19b8bd6c098bea621e",
        "index": 123,
        "pageIndicators": {
            "current": "2",
            "total": "2"
        },
        "title": "Road to Dynamic Server Meshing",
        "subtitle": "Special Thanks goes to the following community members",
        "texts": [
            "Bambooza",
            "LeakimX",
            "StarA",
            "Kenge84",
            "Maarkreidi",
            "FelixReynolds",
            "ShinyHobo",
            "Lannar",
            "AngoGonTal",
            "Nazeris",
            "AstroSam",
            "Star Citizen esko  Slovensko",
            "Dani",
            "Mitch van Hayden",
            "Space Tomato",
            "DG360",
            "Sudo",
            "Wurzel",
            "Sawyer"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/1/9/8/b/6/ebe60514a3195ebcbf689bf6c241200.png"
    },
    {
        "uuid": "1e3920161abf3d9636dd29d796fa1bbf95281438",
        "index": 124
    },
    {
        "uuid": "acc6a4dd18ff6687061ee3919d9b36f9f7d718f6",
        "index": 125,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "LUA Removal & C++ Entity Components",
        "subtitle": "",
        "texts": [
            "In order for Object Containers to be implemented, there were a few things that needed to be done first.",
            "Challenges:",
            "* loading and initializing objects from drive into memory takes a long time (>200ms, multiple game ticks long)",
            "* to prevent long wait times, freezes and stuttering in the game, the loading and initialization process had to be executed separately and in parallel to the main thread which runs the game loop and thus game logic",
            "* a lot of the game logic was written in the script language LUA which made it impossible to run the game logic multi-thread safe but is a requirement to run parts of the game code in parallel on other CPU cores",
            "* dynamic objects (or also known under the term \"entities\") and their game logic was written in large, monolithic code classes which makes it difficult to maintain, expand and multi-thread the code",
            "Solution: Replace the old LUA game logic code with a new Entity Component architecture in C++ (speculated: not to be confused with an Entity Component System architecture) (may also be known as Item 2.0) (also not to be confused with ship components)",
            "Requirement for: Object Containers",
            "Goals:",
            "* introduce a multi-threadable Entity Component architecture in C++",
            "Approach:",
            "* the monolithic LUA code was converted into a C++ Entity Component where individual behaviors in the game are put into each their own components which could then be easily attributed to any entity",
            "* in October 2019 they had between 300 to 400 individual components implemented and available",
            "* each entity is then composed out of multiple components",
            "* this new game logic written in C++ allows for safe multi-threaded code execution (game simulation, more about this in the Multithreaded Loading & Execution topic)"
        ],
        "sources": [
            "jp1",
            "atv6",
            "atv7",
            "rtv1",
            "hh1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/1/c/5/5/fcdf79243cbad37605c25a1944f1200.png"
    },
    {
        "uuid": "6642659ecdc1ae7c598706b5bc68b1427a769481",
        "index": 126
    },
    {
        "uuid": "7203bc87c7fac607ea011c8c153d1a6f418b15e9",
        "index": 127,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Multi-Threaded Loading & Execution",
        "subtitle": "Overview",
        "texts": [
            "In any game there are many Resources (e.g. textures, geometry meshes), which have to all be loaded into memory.",
            "Challenges:",
            "* loading large objects like spaceships into memory caused noticeable stuttering and freezes because the loading and following initialization process can take long amounts of time (>200ms) and this process being performed by the main thread on which the game simulation logic was being executed on, lead to those stutters and freezes.",
            "* the game already loads Resources (like textures and geometry meshes into) the GPUs VRAM in a parallelized and organized way. However, with the introduction of Object Containers, there needed to be additional logic to ensure that Resources are loaded only once whenever they shared by multiple Object Containers and those Object Containers are loaded at the same time in parallel.",
            "Solution: Multi-Threaded Game Simulation and Loading of Resources and Entity Components, an long-going project to move loading into background threads and optimize the logic for parallel loading (work was on-going well into the Alpha 3.x releases)",
            "Requirement for: Object Containers, Object Container Streaming",
            "Goals:",
            "* load each Resource only once instead of multiple times to save memory while being able to load multiple Object Containers in parallel which may or may not share one or more Resources",
            "* run the game simulation in multiple threads to allow for more entities to be computed in one game tick on the server and client",
            "Approach:",
            "* put the loading process of Object Containers, their Resources and Entity Component into a background thread",
            "* use Fibers (similar to Coroutines) to have more control over the loading process of Object Containers",
            "* keep track of the already loaded resources to reuse them for multiple object containers instead of loading them multiple times",
            "* these changes were partially rolled out with Alpha 3.2, reducing stuttering and freezing noticeably",
            "* with the introduction of Entity Components, the simulation logic was changed to have Component updates be executed in parallel. Therefore, the game simulation part of the game loop has been multithreaded as well.",
            "* This is part of the Entity Component Update Scheduler. It also allows the simulation of individual components to be paused. This was based on distance to players, meaning that certain entities might have been loaded, but were not simulated until players were moving closer.",
            "* furthermore, the loading process and the game simulation logic is not allowed to make changes to the same memory areas and therefore have to be managed to not interfere with each other. Otherwise, this may lead to unexpected behavior, like data corruption and game crashes. Therefore, the loading process has to wait until the game simulation of the current game tick has completed and only then add any loaded objects to the level. Likewise, the game simulation has to wait when the loading process is busy with adding objects."
        ],
        "sources": [
            "jp1",
            "s112",
            "rtv1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/2/0/d/f/c399e9c49178846a1f3ec0dc8a21200.png"
    },
    {
        "uuid": "4648e1e7906ca47eb4f6c6a4dbfa4e594b4bd339",
        "index": 128
    },
    {
        "uuid": "fae304d5b445a490e3c587165fc41cce7c7b085d",
        "index": 129,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "MegaMap",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* currently, when loading a level (like the PU, Arena Commander, Star Marine, even the main menu because that's a level too), first the old level has to be unloaded entirely to then to load the new level into memory. Also network connections to servers have to be disconnected and established again. This increases loading times significantly.",
            "* this also leads to inefficient transition between different levels/scenes from a memory perspective. Some resources (like models and textures) that are used in both levels are first unloaded then directly loaded again unnecessarily and instead could have stuck around in memory to be reused.",
            "Solution: MegaMap",
            "Goals:",
            "* be able to load and unload Object Containers and their Resources \"globally\" (rather than loaded as part of a specific level) to be able to reuse them across many levels.",
            "* from a memory perspective, only one large \"level\" exists now, in which everything is loaded into, making switches between different levels, gamemodes and servers much more efficient and faster.",
            "Approach:",
            "* all content will be loaded into a \"single level\", the MegaMap, where object containers and object resources (like geometry, textures, sounds, etc.) can stay in memory, loaded and unloaded at any time, even being able to easily switch between different gamemodes (singleplayer and multiplayer levels) without having to unload everything first",
            "* this feature will be used someday to seamlessly access Arena Commander, Star Marine and Theatres of War and other gamemodes from inside the Persistent Universe as in-game, in-lore video games",
            "* speculated: the name \"MegaMap\" likely refers to the Map data structure. Essentially a lookup table in which all Resources are loaded into and accessed via a key/name. With all resources stored in this Map, it would be a \"Mega Map\". Therefore, this would have nothing to do with the 64bit floating point coordinates for large levels (next topic)."
        ],
        "sources": [
            "atv3"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/0/1/9/4/3/f0e4a7f472791134f9f52e250c21200.png"
    },
    {
        "uuid": "6c1f1257e52132cebe1caccf8cb0f1c6b4e59f2a",
        "index": 130
    },
    {
        "uuid": "e12af6d84f58b813042973263a1f2d0e9317a94a",
        "index": 131,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "64bit floating point coordinates & 64bit integer entity id conversion",
        "subtitle": "",
        "texts": [
            "As explained at the Introduction section of the presentation already, a 3D level has three dimensions: x, y and z. Therefore, each object in the game has three floating point values representing the coordinates in space. The position of an object in the level might be (x=5.12 | y=204.7 | z=-167.826). These numbers arent \"tracking\" the objects position, but are actually determining it.",
            "Challenges:",
            "* like most game engines the engine currently uses a floating point type with 32bits for these three coordinate values",
            "* compared to 'integer' numbers, 'floating point' numbers can represent very large numbers by using 8bits as exponent and 24bits for the significand/fraction. With this math, the decimal point can be moved around, hence the name \"floating point\".",
            "* however the downside is that large numbers lose precision therefore making it only useful for small game levels (~8km max) with sizes of a few kilometers because anything larger would result in more and more precision inaccuracies leading to movement being imprecise and stuttering more and more the further away an object is from the center of the level (x=0, y=0, z=0)",
            "* additionally, with eventually thousands of players and probably billions of unique entities in the game over the course of the games lifetime, each entity in the game requires its own unique id; currently the 32bit value allows for 4,294,967,295 unique entities",
            "Solution: 64bit floating point coordinates (also referred to as Large Worlds) and 64bit integer entity identifierse",
            "Requirement for: Object Containers, zones, 64bit to 32bit converter",
            "Goals:",
            "* larger levels which can contain an entire solar system with its planets and locations",
            "Approach:",
            "* convert all coordinate values from 32bit to 64bit type (double-precision floating-point format) (Large Worlds)",
            "* most of the game logic/code of objects/entities/components has to be changed for this conversion",
            "* with this change, level size doesnt just double, it actually allows for MUCH larger levels (almost 9 billion of kilometers in size)",
            "* for the entity ids, using an unsigned 64bit integer would allow for 18,446,744,073,709,551,615 unique entities which would definitely be plenty for many decades to come; having a global id for each entity in the game will make logic for server meshing much easier when entities are uniquely identified by all game servers"
        ],
        "sources": [
            "gc1",
            "s114",
            "df1",
            "df2",
            "w7-9"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/c/5/b/1/56df26542e795a307e39a168e4d1200.png"
    },
    {
        "uuid": "4164f09306e666c031186110aaa9115043c13e6e",
        "index": 132
    },
    {
        "uuid": "e96a563aeeb9f7c77c280bb3915e87488c322fc8",
        "index": 133,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "ZoneSystem",
        "subtitle": "Challenges:",
        "texts": [
            "* since the game is going to feature a lot of moving and rotating entities (e.g. planets, spacestations, ships, public transport, other vehicles) a lot of objects inside all of those entities would have to update their position in the level as well",
            "* objects can be inside of other objects thus objects would have to be moved multiple levels deep",
            "* this would lead to a lot of computational load and has a high chance of leading to issues like movement and hitbox jankiness",
            "* currently each code system (rendering, network updates, physics) has its own custom partitioning system some of which dont work well in these new large 64bit coordinate systems",
            "Solution: ZoneSystem and its Zones, a unified, custom spatial partitioning system (despite its name, it has nothing to do with zoning/instacing of game areas like many MMOs do)",
            "Requirement for: Object Containers, 64bit to 32bit converter, OCS, Server Meshing",
            "Goals:",
            "* allow for large groups of objects to move and rotate with little CPU computation required by introducing zones",
            "* have these zones be a unified system for rendering, visibility occlusion, network optimizations, physics, level streaming, AI, etc.",
            "Approach:",
            "* this replaces the Octree datastructure previously used to partition the game level into cubic, immovable chunks",
            "* the new zones can be of different sizes",
            "* each planet, station, ship, room etc. receives its own zone and each zone has its own 64bit floating point coordinate system",
            "* objects which are inside a zone are positioned relative to that zone, not to the level world coordinates",
            "* if a zone moves, its coordinate system moves with it and that in turn moves all objects inside",
            "* therefore, to move all objects inside of a ship/planet/etc., only the position of the ship (\"zone host\") has to be updated",
            "* this makes large ships essentially its own moving level inside another even larger level",
            "* zones can be nested, thus smaller zones can be in other zones and move with the parent zone like all the other objects, for example solar system->planet->landing zone->room->ship->vehicle",
            "* those smaller zones can enter and leave larger zones (like the zone of a vehicle parked inside the zone of a ship)",
            "* when objects move from one zone into another the object coordinates have to be correctly calculated to ensure a smooth transition from one coordinate system to the other",
            "* initial work was done/completed in August 2014",
            "* was changed to an AABB tree data strucuture in June 2016",
            "* (speculated: it is highly likely that zones are going to be used for OCS and Server Meshing for networking, streaming and to partition the game world into sections to be run on separate game servers)"
        ],
        "sources": [
            "z1",
            "z2",
            "z3",
            "gc1",
            "mr1",
            "mr2",
            "w6"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/9/6/c/d/064968f41178c355b6ece39d2101200.png"
    },
    {
        "uuid": "ed0d76e1d3335a85e9362e482d77beb9e345101a",
        "index": 134
    },
    {
        "uuid": "93463bf9f514d06397f8f0cba78f846a73566c88",
        "index": 135,
        "imageURLs": [
            "https://media.preziusercontent.com/media/4/4/c/8/2/853c92940ed8b7a1ce68051ed41.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "64bit to 32bit converter",
        "subtitle": "Overview",
        "texts": [
            "We now use 64bit floating point value coordinates",
            "to allow for large level sizes.",
            "Challenges:",
            "* however, GPUs are much more efficient when",
            "being able to use 32bit floating point values",
            "for their calculations when rendering images",
            "Solution: 64bit to 32bit converter",
            "Requirement for: Object Containers",
            "Goals:",
            "* have a 64bit world size to simulate the objects within and at the same time allow the GPU to use 32bit coordinates to render the game",
            "Approach:",
            "* therefore, a 64bit to 32bit floating point zone-to-world converter and a world-to-camera relative space converter were implemented that turns those 64bit world coordinates into 32bit coordinates for the renderer where the player camera is being placed at (0,0,0)",
            "* other objects are then positioned relative to the player camera",
            "* this assures that the precision directly around the player is very high; objects further away (like planets or moons) might be slightly mispositioned but that is barely noticeable at such distances"
        ],
        "sources": [
            "atv4",
            "s114"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/8/3/8/d/a/c16318f4930aa700b413ad883de1200.png"
    },
    {
        "uuid": "349684c4e648d7b4cb05fb454e00242c545cf8f2",
        "index": 136
    },
    {
        "uuid": "e2522b387cd2085b39ee66f80301447212d597b3",
        "index": 137,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Serialized Variables",
        "subtitle": "Overview",
        "texts": [
            "Since Star Citizen is an online game it has to communicate the state of entities between the server and the clients to have the game world stay synchronized between multiple players.",
            "Challenges:",
            "* entities in games have values attributed to them (essentially their data) which can change on each game tick",
            "* these values (also called variables) are in memory but they also have to be communicated over the network or persisted (e.g. saved on the drive as a save file or into a database)",
            "* sending all values of all entities on every game tick (30 times a second) over the network would be a very high amount of data and would put a lot of load onto the bandwidth, servers and clients",
            "* trying to setup networking on each value manually in the code as a developer can be error prone which results in desyncs and crashes",
            "* the new Entity Component System makes this near impossible because an entity can have any number of components and thus each entity would be unique and had to be manually set up for networking (which kind of defeats the purpose of using components in the first place because they are supposed to be easily reusable with not much additional work)",
            "Solution: Serialized Variables or Serialized Variables API",
            "Requirement for: Object Containers, Save Files, Networking, Persistence, Persistent Entity Streaming, Serialized Variable Culling, EntityGraph/Item Cache",
            "Goals:",
            "* create an unified mechanism, an Application Programming Interface (API), which lets developers easily network variables and persist data",
            "Approach:",
            "* the API lets developers mark variables of entities as serializable/\"networkable\"",
            "* not only can they set if a variable is serializable, but also if it needs to be newtorked on every game tick or only when the value changed",
            "* this gives developers greater control of how a variable is supposed to be networked while also making it way less error prone to code",
            "* let developers group variables to have them always be networked together (for performance reasons in case a specific group of variables always or very likely are changing together. If one variable in a group changed, then the check for the other variables in the group can be skipped)",
            "* while the game is running, detect when a variable changed its state",
            "* instead of sending all variables of all entities on each game tick, only send the variables that changed, therefore reducing send data and bandwidth",
            "* bundle/wrap changed variables together and serialize them (basically turning them into a networking friendly format which can then be unserialized again on the receiving end). the same can be used to save/persist the entity data into a file or database",
            "* used by Persistent Entity Streaming in Alpha 3.18 for persisting all serialized variables of all entities. Prior, only some of the serialized variables of some of the entities were persisted."
        ],
        "sources": [
            "atv1",
            "jp1",
            "scl2",
            "s117"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/9/1/2/a/8/182fa0744aea1234f9fa02b98c71200.png"
    },
    {
        "uuid": "a77c9c6062fdb03ee389e6d72bcb524e6adbde79",
        "index": 138
    },
    {
        "uuid": "ca8a053070587df55e7ce0388ac111a4cb9e9cfc",
        "index": 139,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Entity Component Update Scheduler",
        "subtitle": "Challenges:",
        "texts": [
            "* for Client Object Container Streaming it will be necessary to load and unload entities to and start and stop sending state updates to the client to reduce RAM and CPU usage so we require information on when we can do that",
            "Solution: Entity Component Update Scheduler (released in 3.0, most likely a result of the Simulation Multithreading initiative)",
            "Requirement for: Serialized Variable Culling, Client Object Container Streaming",
            "Goals:",
            "* update all entity components on each game tick in the game loop on the server",
            "* provide information of the distance and visibility of each entity in regards to each player",
            "* limit network updates to the clients based on those distance and visibility information",
            "Approach:",
            "* the Entity Component Update Scheduler already provides the required information about distance, size and visibility of entities in relation to the players",
            "* since 3.0, the server already used that info to be able to start and stop simulating individual components as well as start and stop sending network updates to client of entities that are too far away from all (!) the players in the level.",
            "* each Component type can be given a different update policy for more fine control when they should be simulated/networked",
            "* This already saves performance as not all entities are simulated and send network updates to the clients.",
            "* However, this still sends entity updates to ALL clients if only a single player is near an entity, even tho other players might be far away from that entity (this was later changed with the Serialized Variable Culling feature)",
            "* these network policies will play a vital role in server meshing to ensure player clients perform well when hundreds of entities are around a player by skipping network updates for far away entities (where such skips are noticed less) thus reducing load on the client CPU",
            "* speculated: interpolation techniques might allow far away entities to still have smooth motion, even though their state might not be 100% accurate all the time",
            "* for OCS, the Entity Component Update Scheduler will be used for the loading and unloading of entities because it already provides the required information about the distance, size and visibility of entities to the players",
            "* The ECUS was updated in Alpha 3.17 improving the simulation performance greatly (made it entity-centric, use Zone Host Updates and more)."
        ],
        "sources": [
            "jp1",
            "s104",
            "s112",
            "s113",
            "mr3",
            "pn317",
            "s303"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/2/e/c/8/2ba5c45483b9fe74d5d3c2a52181200.png"
    },
    {
        "uuid": "46126a413f96bbc102fba317b7bd9e7db34449d8",
        "index": 140
    },
    {
        "uuid": "59cdf9cd07fa3fc9f5039241358506c33a31fe8e",
        "index": 141,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Entity Ownership Hierarchy / Entity Aggregates",
        "subtitle": "Overview",
        "texts": [
            "At level design time, Object Containers can be nested to create larger game areas out of smaller objects. However, there needs to be additional logic at runtime. Some entities are made up of smaller entities. And how these are made up can change while playing.",
            "Challenges:",
            "* These entity groups need to be represented in memory.",
            "* These groups and hierarchies can cause issue when these objects are not loaded/unloaded in the correct order.",
            "Solution: Entity Ownership Hierarchy / Entity Aggregates (released in Alpha 3.0) (speculated: scene graph)",
            "Requirement for: Entity Spawn Batches & Entity Snapshots, Client Object Container Streaming",
            "Goals:",
            "* It is required to keep track when those dynamic groups are formed or disbanded.",
            "* Load and unload groups of entities in the correct order (e.g. the ship exterior needs to be loaded before the ship interior, as the inner ship's state partially defined by the outer ship)",
            "Approach:",
            "* A group of entities - which are related to each other and form a larger entity - are called an Entity Aggregate (or Entity Root or Logical Entity). Examples:",
            "* A weapon is the entity root and its attachments are entities attached to the weapon.",
            "* A player character (entity root) picks up an item and holds it in its hand and moves around with the player.",
            "* Entities can move in and out of each other, like ships and vehicles moving into other ships (speculated: therefore, this might be related to the zone system)",
            "* How entities are related to each other is kept track in an Entity Ownership Hierarchy.",
            "* Together with the Entity Component Update Scheduler, the server decides which Entity Aggregate(s) to load and unload on each client (by sending the equivalent Object Containers and Entity Snapshot updates).",
            "* In the EntityGraph database, entities that are Entity Roots are labeled as such on the node (for queries)."
        ],
        "sources": [
            "jp1",
            "c2"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "09a2ea34847311e2ba355b437a48f6326d2742fc",
        "index": 142
    },
    {
        "uuid": "1db3224354fa34dee05460851ef31bacd5e8595d",
        "index": 143,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Entity Spawn Batches & Entity Snapshots",
        "subtitle": "Overview",
        "texts": [
            "With the server now being able to notify the client to load entities into memory it was time to handle the loading part on the client.",
            "Challenges:",
            "* entities need to spawn in a consistent way on the client so that client and server end up with the same Entity Aggregates and Entity Hierarchy in memory",
            "Solution: Entity Spawn Batches & Entity Snapshots (released in Alpha 3.0)",
            "Requirement for: Client Object Container Streaming",
            "Goals:",
            "* handle the data send by the server on the client to load objects in the correct order into memory",
            "Approach:",
            "* the server groups entities which should spawn together into an Entity Spawn Batch",
            "* the entities only become active (being computed in the game loop) once all entities in the batch are loaded",
            "* for each entity, the server creates an Entity Snapshot (with the help of Serialized Variables) containing the entire state (all variables and their values) of the entity and sends it to the client (speculated: maybe just those that are non-default values)",
            "* while the entities are being loaded they are not being networked yet to stay synchronized. The process of loading objects in the background takes time which can lead to the object state being different on the server and client. This is solved by the server sending a second Entity Snapshot once all entities are loaded. The client updates the state to be in line with the server and then the entities can become active and networked to stay in sync with continuous updates from the server",
            "* Since networking can be started and stopped (thus network updates skipped) for individual entities any time, entities are not necessarily unloaded directly when they dont receive updates anymore. They might stick around in memory for a while and continue receiving updates again later. Then a Entity Snapshot is send again to ensure the entity has the right state."
        ],
        "sources": [
            "jp1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/3/e/5/9/d84c99f476694ffda2406a23fae1200.png"
    },
    {
        "uuid": "cd1f88551d6dd4150ad73e6767b4728c8a314cf7",
        "index": 144
    },
    {
        "uuid": "f25f91dbc432178cb282860184c08d1ff1c0bfd6",
        "index": 145,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Serialized Variable Culling",
        "subtitle": "Overview",
        "texts": [
            "Thanks to the Entity Component Update Scheduler, the server was already able to skip updates of certain entities when they are far away from the players.",
            "Challenges:",
            "* however each client was still send all updates of all entitiy around ALL players and thus had to update their components when new network information was received from the game server",
            "* this put unnecessary load on the client CPU by having it compute objects in far away places (at the time the in-development Persistent Universe consisted of Port Olisar, Levski and GrimHEX and players could already be far apart)",
            "Solution: Serialized Variable Culling (released in Alpha 3.1)",
            "Requirement for: Client Object Container Streaming",
            "Goals:",
            "* only send updates of the entities which are in near proximity of the player to that specific client",
            "* for the first time, it allowed CIG to run the client on partial information about the game world running on the game server",
            "Approach:",
            "* utilize the already created software systems (mainly the Entity-Component-Update-Scheduler and likely its networking policies) to determine which client requires which object data",
            "* put a system in place that will only send network updates to the client that is in the near proximity of the updated entity",
            "* now each client only receives the information that that specific client requires, reducing the load on the client CPU"
        ],
        "sources": [
            "jp1",
            "rtv1",
            "s113"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "bd66bf9c68d763728a0de648f37569f9d8788080",
        "index": 146
    },
    {
        "uuid": "7f2221509b1ac628176f9286842637df7a275ef3",
        "index": 147,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Network Bind Culling / Entity Bind Culling",
        "subtitle": "Overview",
        "texts": [
            "With Serialized Variable Culling each client only received network updates of entities which are near that player.",
            "Challenges:",
            "* however, the player still had to load all entities on level start and keep them loaded in memory even if they were far away and not being networked",
            "Solution: Network Bind Culling (released in Alpha 3.3, also referred to as Entity Bind Culling later on)",
            "Requirement for: Client Object Container Streaming",
            "Goals:",
            "* load and unload entities to/from memory on the client based on the position position in the level",
            "Approach:",
            "* the server tells the client when to load which entities into memory (by using the Object Containers and their identifiers)",
            "* entities are loaded based on the information provided in the Entity Component Update Scheduler",
            "* we are finally at a position where the client has a truly partial view into the game world on the server, completing the functionality of Client OCS",
            "* the game world on the server could now be increased, adding more locations, without requiring clients to load them into memory as well"
        ],
        "sources": [
            "jp1",
            "rtv1",
            "cc2"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/0/6/0/4/5/9b8fa4d4a96bf755b76d052a11c1200.png"
    },
    {
        "uuid": "4f862faf5803098138e0c4964563ad268aefbe62",
        "index": 148
    },
    {
        "uuid": "608b7eb6cfc0853afef5b69a06de6a5b13bb1fdb",
        "index": 149,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Entity Streaming Manager & StarHash",
        "subtitle": "Overview",
        "texts": [
            "Without Server OCS, the entire game world was always loaded in memory on the server in the in-process database.",
            "Challenges:",
            "* there needs to be a fast way to query the database for objects in a certain area in the game world so that objects can be loaded around a player who is moving through it",
            "Solution: Entity Streaming Manager with on-drive database, StarHash and StarHash-RadixTree",
            "Requirement for: Server Object Container Streaming, iCache, Global Persistence, Static Server Meshing",
            "Goals:",
            "* make changes to the current in-memory database on the server to have it more in line with the requirements of persisting items in the game world",
            "Approach:",
            "* use a modified version of a Geohash algorithm usually used for map application to find points of interests around the users and call it StarHash",
            "* make the Geohash 3D (xyz axis) instead of 2D (longitude & latitude) and use 64bit floating points for the coordinates",
            "* when saving an object, generate a unique hash code based on the xyz positions of an object in the level",
            "* to perform quick look-ups, the objects are indexed via a Radix Tree data structure (usually has a O(k) worst case look-up performance with k being the length of the hash code)",
            "* when players move around in the level, the Entity Streaming Manager can now look up the database for all objects that exist around the players. Those objects are then loaded into memory, initialized and processed in the game loop",
            "* this database system will most likely be used and expanded upon for the Item Cache databases and Server Meshing"
        ],
        "sources": [
            "jp1",
            "w4",
            "w5"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/e/e/1/5/54feac947da9fd9414cb31db4bf1200.png"
    },
    {
        "uuid": "a0e9b441499397ddcf2aa07ad8e71a8ef9e9d3f3",
        "index": 150
    },
    {
        "uuid": "e511ff2aae6b33cc4e2f853e9193fc91971ab64b",
        "index": 151,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Definitive State & Location IDs",
        "subtitle": "Overview",
        "texts": [
            "With the entities not being loaded and accessible in server memory anymore, some issues arose because of it that needed to be deal with before Server Object Container Streaming was able to come online.",
            "Challenges:",
            "* in some situations, especially when players are teleported into an unloaded area (e.g. when (re)spawning), where everything has to be loaded, certain entities have to be loaded before others, like the floor before spawning NPCs, otherwise NPCs fall and are never seen again (this was not an issue for Client OCS because there the second Entity Snapshots from the server was able to adjusted the position of NPCs again and move it on top of the floor)",
            "* some components that are only executed on the server were not yet unloaded to the database (because they previously did not need to since they always stayed in memory)",
            "* when a player connects, its player entity is always spawned at a SpawnLocation which in itself is an entity but that leads to an issue because the system only loads all entities including the SpawnLocation entity when players are nearby (how the system is setup, SpawnLocations cant be an exception and excluded from the streaming process)",
            "Solution: lots of bug fixing and the introduction of Location IDs",
            "Requirement for: Server Object Container Streaming",
            "Goals:",
            "* fix the remaining issues caused by not having all objects loaded in memory at all times anymore",
            "Approach:",
            "* load world geometry and other objects in the correct order to have them loaded just like they were persisted",
            "* finish work to be able to persist all components in the game",
            "* to fix the SpawnLocation issue, a two phase spawning process was introduced: When a player connects it loads the players LocationID which essentially is just a point in space. It is used to spawn in objects at that point which includes the SpawnLocation. Once that is loaded, the player is spawned and the world loads around the player"
        ],
        "sources": [
            "jp1"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "468495f2c7daa0f97cc3fc3601b1d095984152e2",
        "index": 152
    },
    {
        "uuid": "6164257a1902973d32247775e3a2d828a8d100a7",
        "index": 153,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Persistent Item DB & pCache (persistenceCache)",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* Before Server OCS, all entities are stored in the game engine memory. However, for persistence to come online, if the game server goes down, then all data in memory will be lost. Not ideal, for a game that aims to have a persistent game world where everything has to keep existing, even between game server reboots.",
            "* Looking at the requirements under Server Meshing, multiple game servers will need to access the same game world data, and therefore this data needs to be made accessible to all game servers in a centralized place",
            "* However, for now there only needs to be a prototype database backend put in place to bring the first version of Server OCS online and to figure out which requirements Full Persistence has.",
            "Solution: Persistent Item DB & pCache,",
            "Requirement for: Server OCS",
            "Goals:",
            "* Bring the first version of Server OCS online by creating a prototype a first prototype backend for persistence",
            "Approach:",
            "* Create the prototype persistence backend for Server OCS, using an in-memory database cache called pCache, which (speculated) connects the data to an on-drive database called Persistent Item DB.",
            "* While running, the game server can now offload entities into the cache and database and load it again depending on where players are in the game world. This uses the SOCS functionality.",
            "* This prototype solution used a relational database.",
            "* This prototype was planned to be replaced by a proper and scalable database that would sit outside the game server. This was initially supposed to be iCache. However, the initial R&D continued working out a scalable solution using a relational database, but at the end of 2020 this turned out that it didnt provide the low latency and performance CIG were looking for. Starting 2021, they switched to a graph database instead, which showed results internally for the first time in Mai 2022, expected to come online with PES in the Alpha 3.18 patch."
        ],
        "sources": [
            "s101",
            "s102",
            "lc1"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "f83f28146ee47bf4eab5982d848f7505c45e498d",
        "index": 154
    },
    {
        "uuid": "6108ac782a0e6d80b597a7697c239002aa05f4b4",
        "index": 155,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Global Database / Long Term Persistence (LTP)",
        "subtitle": "Overview",
        "texts": [
            "So far, every three months on each major patch the player progress is wiped because the database was reset.",
            "Challenges:",
            "* players dont have a lot of incentive to work toward ships and other items (especially ever since in-game ship purchases and rentals came available) because they will be removed again every three months",
            "Solution: Long Term Persistence (LTP, Platform Persistence, \"Baby Persistence\"), later reworked and renamed to 'Global Database'",
            "Goals:",
            "* implement a first version of persistence for player account data",
            "* (note: this feature is not Full Persistence because Full persistence is about saving data of the game world which is what the iCache/EntityGraph database is going to do)",
            "Approach:",
            "* the first version released in Alpha 3.8.2 with",
            "* UEC balance",
            "* Ship purchases and rents",
            "* Ship component purchases",
            "* FPS item purchases",
            "* this allowed the introduction of the currency trading app (mo.TRADER) in Alpha 3.10.0 by utilizing the database that stores the information about the players UEC balance",
            "* this database now saves in-game purchases of ships to allow players to work toward and keep their ships across multiple patches",
            "* \"As of [Alpha] 3.15, Long Term Persistence is broken up into three distinct parts: Items, Wallet (aUEC), and Reputation. Going forward, we will be able to wipe specific parts of LTP individually as needed (for example, wiping Reputation while leaving Wallet and Items intact). This level of flexibility will allow us to do necessary wipes while minimizing the impact on the community.\"",
            "* The Item part of the database is most likely the Global Database holding inventory items of a player across shards.",
            "* Alpha 3.15 also came with an interim implementation for Server Crash Recovery specifically for ships. This was done by checking the Replication Layer cache (containing a snapshot of the physicalized ship entity of the crashed server) for all player ships. Those ships are then stowed into the Global Database (LTP). From there, it then can be spawned again on any server at a ship terminal. The interior (including cargo) is spawned and available as well. This was a first workaround before the actual server crash recovery that will allow us to keep playing exactly where the game left us of (e.g. inside our ship while in Quantum Travelling)."
        ],
        "sources": [
            "s108",
            "s115",
            "s116",
            "cad1"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "78de0a20d2dbf4c7387a6ed4660460eced6307e5",
        "index": 156
    },
    {
        "uuid": "ea549542d5a9dd2b85acf1d52381facd130d15cd",
        "index": 157,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "EntityGraph / iCache (Item Cache)",
        "subtitle": "[cc2,scl2,cad1,s102,s103,s107,s109m,s110,",
        "texts": [
            "s201,sc1,mdb1,mdb2,pn315,lc1]",
            "For the state of the game world universe to be persisted within a meshed server environment, all entity data needs to be stored in such away that they become accessible to all game servers in a responsive, low-latency manner.",
            "Challenges:",
            "* with each game server accessing its own in-memory pCache database, actual persistence of items ingame is barely existent",
            "* the current pCache database does not support the functionality for full persistence yet, e.g. items which are just laying around on the ground",
            "Solution: EntityGraph (initially known as iCache or Item Cache, or Super pCache)",
            "Requirement for: Full Persistence, Physicalized Items and Inventory, Server Meshing",
            "Goals: build a new, horizontally scalable, shardable database that can persists all entities in the game world and serve all game servers in a performant and thus responsive way (and allow for crash recovery down the line)",
            "Approach:",
            "* create a horizontally scalable database called EntityGraph which persist entity data, and a scalable cache (for within the Replication Layer, sometimes referred to be iCache)",
            "* improves the response times for backend database requests",
            "* uses best practices for fault tolerance and recovery via data replication and automatic regeneration in case a database instance crashes",
            "* this should also help reduce the load on each individual database instance, as data can be replicated/sharded onto separate instances",
            "* these services can be scaled freely independent of game servers and shards",
            "* EntityGraph is a graph database: all entities in a level form a large hierarchy which can be represented as a graph data structure",
            "* each entity in the game world is represented as nodes in the database, while relationships between entities are edges",
            "* changing state of individual entities as well as changing relationships by adding or deleting edges are both cheap/fast operations in a graph database",
            "* allows entities to be queried based on shard, star system, xyz position, object size and distance to players, entity type and custom labels",
            "* entities and sub-trees can form entity aggregates which are streamed in together. They can also be given a label which allows for queries that requests specific types of entities to be returned",
            "* with full persistence every entity anywhere in the level can be persisted, not just in pre-determined places such as weapon racks",
            "* speculated: EntityGraph uses ArangoDB.",
            "* Introduces Characters Repairs (instead of Character Resets) as well as Entity Lifetime for Item Cleanup logic."
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "5c5a2bdb76618e16b1b3c344441f9ffffca54303",
        "index": 158
    },
    {
        "uuid": "aebab2d1de6a383b94629849d63ebf6018bd2c85",
        "index": 159,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Global Persistence",
        "subtitle": "Overview",
        "texts": [
            "With the cache/EntityGraph database we now provide a centralized place for all game servers to access entity data.",
            "Challenges:",
            "* the game servers still access the data in the old pCache database, not the new EntityGraph one",
            "Solution: Global Persistence, which makes Server OCS utilize the new cache/EntityGraph and Global Database, of which a first version came online with Alpha 3.15 (speculated: utilizing the cache in the Replication Layer)",
            "Requirement for: Physicalized and Persisted Items and Inventory, Replication Layer, Static Server Meshing, Squadron 42",
            "Goals:",
            "* let the game servers utilize the entity and inventory data stored in the EntityGraph and Global Database (LTP)",
            "* with state of entities being persisted long-term, more gameplay that utilizes the functionality of items existing in the game world long-term in the game world will be implemented and introduced into the game",
            "Approach (speculated):",
            "* change/extend Server OCS with this new functionality",
            "* this is the interface between the game server and the database(s)",
            "* while players move through the game world, the Replication Layer asks an EntityGraph database if there are any entities in the area that a player is about to move into; or entities moving into the area of a player",
            "* let the game server load those entities into memory via Server OCS and start computing them in the game loop by the CPU",
            "* when players leave an area behind them, serialize and send the entity state to the EntityGraph database (or Global Database in terms of Inventories and ships) to have it be saved and persisted",
            "* unload the entity from memory to make room for new ones which is already part of Server OCS capabilities",
            "* the Replication layer might periodically persist the state of entities to prevent data loss on a server crash",
            "* this functionality will also be used by the singleplayer game Squadron 42 to access the local database (offline)"
        ],
        "sources": [
            "s101",
            "s102",
            "cad1",
            "jp1"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "81be80d0ea3d0aa5e0d9085633780e930f48b748",
        "index": 160
    },
    {
        "uuid": "fb76f78db316308af31e3cb638f7f2d7f00680fa",
        "index": 161,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Local, External and Personal Inventory",
        "subtitle": "Overview",
        "texts": [
            "The first versions of inventory and item management will consist of a personal inventory (what the players can carry directly on them), external inventory (e.g. a cargo box or backpack) and local inventory (ships and landing zones). The local inventory is going to be an intermediate version toward fully Physicalized Items and Inventories. Items will initally be stored on ships in these local inventories and accessible via UI. Through iteration, more and more items will be physicalized as \"real\" objects which take up space in the game world and the local inventories will be phased out. At the same time more physicalized inventories will be introduced that will allow players and NPCs to store these physicalized items directly inside physical inventories.",
            "First version came online",
            "in Alpha 3.15."
        ],
        "sources": [
            "cad2"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/a/b/f/0/6df618a4e0b882401b397cd98cb1200.png"
    },
    {
        "uuid": "748b0a56f1d9957e13e0bdeb19262a9d8244ad41",
        "index": 162
    },
    {
        "uuid": "b501435751dbae2d7f7603154ad94b854d3085a0",
        "index": 163,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Physicalized Items and Inventory",
        "subtitle": "Overview",
        "texts": [
            "With the cache in the Replication Layer we have a centralized place to store all entity data and with Global Persistence the game servers are able to utilize that data.",
            "Challenges:",
            "* items are still very simple in their design and how the player can interact with them",
            "* character inventories are still very simple in their design because they are merely global account inventories",
            "Solution: Physicalized Items and Inventory, first version came online with Alpha 3.15",
            "Requirement for: Persistent Streaming, Static Server Meshing",
            "Goals:",
            "* have items and inventories be physical objects in the game which take up space",
            "* have items physically present in inventories when you open them (e.g. cargo boxes)",
            "Approach:",
            "* items will be a physical, interactive object in the game",
            "* that even includes stuff like character clothes (with the Cloth Simulation implementation)",
            "* even inventories are going to be physical items in the world, e.g. backpacks and cargo containers which can be put on the ground, moved around and picked up again (utilizing the Grabby Hands implementation)",
            "* allow items to have child items",
            "* allows the player to put items into other items, e.g. a battery into an electronic device (with Item Ports)",
            "* allows hierarchies of nested items (bullets -> magazine -> gun -> backpack -> player)"
        ],
        "sources": [
            "cad2"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/2/d/a/3/b/6410d3c42d9b51ca35c540c18c01200.png"
    },
    {
        "uuid": "f382eee81e0ddc3b06fcb25534bcb8e06ad0930c",
        "index": 164
    },
    {
        "uuid": "9741d483571cad1f19b5575e32044b3377c6cb62",
        "index": 165,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Stow & Unstow",
        "subtitle": "Overview",
        "texts": [
            "With physicalized items and inventories making its way into the game there needs to be a way to reliably persist and access such information, even if players switch between game instances/shards.",
            "Challenges:",
            "* Entities that physically exist in the game world (items) have to be be put into inventories (stowed) and later taken out again (unstowed)",
            "* Both items and inventories need to be persisted. The physicalized items and physicalized inventories in the game world are now being persisted in the EntityGraph database. However, the non-physicalized items inside of inventories are not.",
            "* Items and Inventories need to be accessible across Shards in Server Meshing, but EntityGraph groups data per-Shard.",
            "Solution: communication between the EntityGraph and Global Database, aka Stow & Unstow",
            "Requirement for: Persistent Streaming, Static Server Meshing",
            "Approach:",
            "* When items are stowed into inventories, they stop existing as physicalized items in the game world and instead as an entry inside the inventory. The contents of inventories are persisted in the Global Database (LTP), instead of the EntityGraph database.",
            "* This allows players to access inventories content (like local and personal inventories), even if they switch to another game instance (or another shard under Server Meshing), since the Global Database stores Shard-independent data.",
            "* Items can be easily moved between inventories. In the database this would be unstowed from the first inventory and directly stowed into the second inventory (most likely a single database transaction).",
            "* Ships - and all items inside - can also be stowed into the Global Database when the ship is stored (e.g. by the player via a terminal) and later spawned/unstowed again",
            "* this allowed for the first introduction of a rudimentary Ship Recovery in the case of a Server Crash (see Global Persistence/LTP for more info)."
        ],
        "sources": [
            "cc2",
            "scl2"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/8/2/a/f/a7a75d14f1dbf305343a54374891200.png"
    },
    {
        "uuid": "b752a4e3fcb58e5eaf04124b5520c09308a5f575",
        "index": 166
    },
    {
        "uuid": "3ff7f382cb4b905d5cb1f781e73b6c6a4271e0dd",
        "index": 167,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Shards",
        "subtitle": "Challenges:",
        "texts": [
            "* Because the backend architecture is getting more complex once moving toward Server Meshing, there needs to be new terminology.",
            "* So far, an entire game world has been simulated by just a single game server.",
            "* Under PES and Server Meshing, players won't play on and send/receive data directly from a single game server anymore, a game world is not referred to as a 'game server' anymore.",
            "Solution: Shards",
            "Requirement for: PES, Server Meshing",
            "Goals:",
            "* use the term Shard to refer to a (meshed) \"game world\" (one copy of the Star Citizen universe)",
            "* sometimes the backend servers and services running one such game world is also referred to as the \"Shard\"",
            "Approach:",
            "* Idealy, everyone plays in the same game world, a single world-wide Shard.",
            "* However, until Server Meshing is capable of doing that, there will still be multiple, independent shards running alongside each other, each with their own game world and state. Therefore, initially there will be a multiverse of SC universes, but economy is shared (via the Quantum Economy Simulator).",
            "* The initial milestone/goal is to scale up Server Meshing far enough to support one Single Sshard per region.",
            "* While playing, players and entities can only ever be transferred between game servers of the same Shard, never to server nodes of a different shard.",
            "* Players can still join/switch to another Shards, but this can only happen from the main menu before they start playing, determined by matchmaking/login-flow"
        ],
        "sources": [
            "cc2",
            "qa1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/c/f/b/2/aab707441c9ba5f2c8629f0fad01200.png"
    },
    {
        "uuid": "27b902378c1a0e7e6000a4ca954955ca77a86eaf",
        "index": 168
    },
    {
        "uuid": "d0dde8ba15637f34372955b91eede68d1954e08a",
        "index": 169,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Server Nodes",
        "subtitle": "Challenges:",
        "texts": [
            "* Because the backend architecture is getting more complex once moving toward Server Meshing, there needs to be new terminology.",
            "* A single Game Server won't simulate the entire game world once Server Meshing comes online.",
            "Solution: Server Nodes (sometimes still DGS, Dedicated Game Server, or simply still game server)",
            "Requirement for: Server Meshing",
            "Goals:",
            "* Game Servers become a horizontally scalable service, meaning multiple game servers can run alongside each other, simulating the same game world (Shard)",
            "* Server Nodes do not perform Replication (and persisting into a local in-memory database) anymore, as this is moved out of the game server and into the Replication Layer (see topic)",
            "Approach:",
            "* Server Nodes are still Game Servers (DGS). As before, they are responsible for simulating the game world, verifying the actions of the players and simulating AI. The difference is that now a specific Server Node might only a part of the game world, and not the entire game world anymore.",
            "* There can be many server nodes computing the same game world. The term server 'node' highlights that it is one of many game servers in a much larger network and those nodes having been setup to work within it.",
            "* To determine which Server Node is computing which part of the game world, a Server Node will be assigned authority (from Atlas) over the entities in that section of the game world. The code logic known as Entity Authority will then perform the correct action on the server, depending on if that server has authority or not (or is about to gain/lose authority when authority is transferred and entities are simulated by another server node afterwards)."
        ],
        "sources": [
            "cc2",
            "qa1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/a/c/8/1/5/e5d1fca411d987af02a995bc80d1200.png"
    },
    {
        "uuid": "592cd45f2a4ae16d14b3be8e950f9f5ba8074766",
        "index": 170
    },
    {
        "uuid": "d7ec29de4d92066d1744922b1e386e49babf9be7",
        "index": 171,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Player Item Shard Transitions",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* Because there will be a large time frame in which we still have multiple game worlds running alongside each other, the multiverse, (because Shards cant be scaled up high enough to support single regional Shards or even a single world-wide Shard), there is a need for players and their items to move between Shards.",
            "Solution: Player Item Shard Transitions",
            "Requirement for: Server Meshing",
            "Goals:",
            "* be able to move players, their items and ships between Shards between play sessions",
            "Approach:",
            "* This will make heavy use of the new EntityGraph and Global Database (LTP) databases.",
            "* Reminder: Items that physically exist as entities in the game world are persisted into the EntityGraph database. Inventory content and stowed ships and vehicles are stored into the Global Database. Entities can be moved between the two databases by stowing and unstowing them.",
            "* When players log out and later log back into the game, they might have to join a different Shard instead of the one they played on previously. Possible reasons might be a full shard or partying up with a friend that has been playing on a different Shard.",
            "* When players log back in and try to join the PU, the Matchmaking service will assign the player to a Shard. If this Shard is different to the one the player previously played on, then the player, the player's items and ships (and their base) are moved from the EntityGraph of the first Shard into and into the EntityGraph of the second Shard. For Alpha 3.18, this will only apply to stowed items.",
            "* Data in the Global database does not have to migrate as it is already Shard-independent (meaning it is available from all shards).",
            "* CIG has talked about ideas on how to handle land claims and bases under the multiverse; They would exist across all game worlds, but in an inactive state except in the shard in which the owner plays on."
        ],
        "sources": [
            "scl2",
            "qa1",
            "scr"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/d/b/b/0/232fa584c4e81be5a03ce0b41c41200.png"
    },
    {
        "uuid": "d6f0d4bb0d12d722ae0d3b11053bad350a54f43e",
        "index": 172
    },
    {
        "uuid": "003b948508ad2c8f0dfbeaa76c17eaa04f576904",
        "index": 173,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Server Crash Recovery & Client Reconnects",
        "subtitle": "Overview",
        "texts": [
            "EntityGraph and the Replication Layer will allow for the recovery of crashed servers and reconnets of disconnected players.",
            "Challenges:",
            "* a server crash would cause major disruptions for the player experience",
            "* especially under Server Meshing you need to be able to restart individual servers instead of having to restart the entire meshed system, which essentially would be all servers if just one server crashes",
            "Solution: Server Crash Recovery and Client Reconnects",
            "Requirement for: Server Meshing",
            "Goals:",
            "* utilize the data stored in the EntityGraph to recover individual, crashed game servers and allow players to continue to play with minimal interruption and barely any loss of player progression and items",
            "Approach:",
            "* in case of a game server crash a new server will be started to take over its job (or an already running server will be utilized)",
            "* the new game server will load the entities (which the crashed server was responsible for) from the EntityGraph",
            "* the new game server will utilize Server OCS to load the entities into its memory",
            "* the Replication Layer will hold the player client connections in the meantime and once the new server is ready to go, the game will continue to simulate for the players.",
            "* speculated: players will only experience a few seconds of disruption and lose barely any of their progress as most of the data is already persisted in the EntityGraph instead of the crashed game server/server node",
            "* Alpha 3.15 also came with crash recovery for ships by checking the EntityGraph (containing the physicalized ship entity) then stowing the ship into the Global Database (LTP). From there, it then can be spawned again on another server by the player at a Terminal with the interior (including cargo) fully available. This was a first workaround before the actual server crash recovery that will allow us to keep playing exactly where the game left us of (e.g. inside our ship while in Quantum Travelling).",
            "* The Replicant and Gateway services are expected to become rather stable (because they dont run complex code, such as the server nodes). Even if one of these services goes down, it is expected take less than a minute for the Relicant and just a few seconds for the Gateway service to be started and the game to be resumed."
        ],
        "sources": [
            "scl2",
            "s109",
            "s110",
            "s116"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/9/a/a/5/2e9eb7146eeb498fff9694ad0531200.png"
    },
    {
        "uuid": "d9315e7af4b909a21eb8c1ad20db35ce1f389993",
        "index": 174
    },
    {
        "uuid": "a03537a348d516163abe3734d553aa987f337e87",
        "index": 175,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Service Migration and Creation",
        "subtitle": "Challenges:",
        "texts": [
            "* with server meshing having multiple game servers compute the same game world (which is just data), those game servers will have to share and access the same data",
            "* the data can not be stored on the game server anymore but made accessible to all game servers",
            "Solution: put everything into its own service for all game servers to access",
            "Requirement for: Persistent Streaming, Server Meshing",
            "Goals:",
            "* use the single responsibility principle of only having the game servers compute the game world for the players while executing separate logic and storing data on separate servers/services",
            "Approach:",
            "* move code and logic that is going to be used by multiple game servers outside of the server code and into a separate service to be run on its own server (not a game server). A few of those required rewrites.",
            "* the network code's Replication Layer (collection of Client OCS minor techs) is moved out of the game server code (into the Hybrid service)",
            "* Matchmaking/Login Flow has been reworked to assign players automatically via various weighted factors onto different servers/shards.",
            "* ATC (Air Traffic Control) has to manage and keep track of free and occupied landing pads and requests from players and NPCs (potentially made by multiple servers or different servers across time).",
            "* a NPC Character Creation Service \"will aid in the creation of AI at specific locations for specific reasons, such as the Quantum Simulation.\"",
            "* NPC Scheduler Service \"is meant to add and remove NPC's to the game, dynamically spawning them into and out of the 'verse based on NPC Archetype, Maximum number of NPC's in a given area, and the probabilities of those NPC Archetypes.\"",
            "* The AI Info Service \"will continuously track the position of players, NPCs, and other entities so that our live-service tools can display them properly in real-time.\"",
            "* NPC Tracker Service \"tracks and records the actions of players and NPCs. In turn, Bounty Hunting gameplay will use this service to expose the actions taken by outlaws so they can be tracked by Bounty Hunters.\"",
            "* Identity Service \"will be a proxy service that will relay information about accounts between the RSI platform, Tavern (Spectrum) and the game client.\"",
            "* Reputation and Org Service \"will introduce the first iteration of persistent reputation between all entities within the Star Citizen universe, as well as persistent NPC organizations.\"",
            "* Reward Service \"tracking stats and data per player, and awarding in-game rewards to them, as well as collecting, persisting and querying those player rewards\"",
            "* Configuration Service: \"This service is responsible for real-time distribution of configuration to services and clients.\"",
            "* the \"Quantum\" Economy Simulator and Virtual AI Service for both Quanta, Virtual NPC and Dynamic Event computation as well as databases related for storing Quantum generated data (probability volumes and values, store commodity prices)",
            "* Subsumption Service/Server Mission Logic \"The porting of core Subsumption mission code to a service and implementation of a select subset of tasks to be used on that service. Includes implementing communication between service and mission logic running on game server.\"",
            "* Services Distributed Load Testing System \"Development of a distributed load testing tool that can simulate service loads and replicate user behaviours\" for testing",
            "* Chrono Service: \"offers a programmatic API for distributed timers and alarms. For example, in the expiry of rental entitlements.\""
        ],
        "sources": [
            "scr",
            "isc1",
            "mr4",
            "lc1",
            "scl2"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/3/0/2/c/7/7abb70b4e2f846bc18e992ff2f11200.png"
    },
    {
        "uuid": "ba8b0d8516b05bdf0f26d05d0848636a2fe77c5b",
        "index": 176
    },
    {
        "uuid": "4c490798e876ec523d5e618ee1c07c1bc41c9de2",
        "index": 177,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Service Fleet Manager",
        "subtitle": "Overview",
        "texts": [
            "For Server Meshing to come online, there needs to be a manager for all servers and services of a Shard. This is going to be the job of the Fleet Manager (part of Shard Manager?). It is going to start and stop services and servers, statically initially, later dynamically under Dynamic Server Meshing. It is already developed with that dynamic functionality in mind.",
            "This is already implemented with having horizontally scalable servers and services in mind, which becomes more promintent under Dynamic Server Meshing.",
            "Note: This has nothing to do with ship fleets. This is about fleets of services/servers."
        ],
        "sources": [
            "qa1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/9/c/a/b/2/cfc7e304899a91138ccba2a235b1200.png"
    },
    {
        "uuid": "2a0b03590199fcce0d6a949549477c9e24ec37f2",
        "index": 178
    },
    {
        "uuid": "bbcb3bf8f7f0b1f6a002ee5e26be0b4c66a68178",
        "index": 179,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Shard Manager",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* a Shard does not consist of a single game server anymore, but multiple servers and services. All of these have to be managed somewhere.",
            "Solution: Shard Manager",
            "Requirement for: Server Meshing",
            "Goals:",
            "* manage all the servers and services of a Shard",
            "* setup all relevant data to have the Shard work properly",
            "Approach:",
            "* Responsible for setting up a new Shard",
            "* by first starting and managing server nodes & services (Fleet Manager?)",
            "* establishing network connections between services and server nodes",
            "* \"seeding\" the EntityGraph database with the initial state of the universe (kind of like a \"big bang\" for that specific SC universe), creating a new game world.",
            "* registering the shard at the Matchmaking service to let players join that Shard."
        ],
        "sources": [
            "qa1",
            "cc2",
            "scr"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/6/a/9/d/9/611adee4ebbb9239becf58379ea1200.png"
    },
    {
        "uuid": "02048f1e3ca374bc9dd6c3c61a630583fa823857",
        "index": 180
    },
    {
        "uuid": "6d2f71de16327d1f7870900315fa63c6a0b2df8e",
        "index": 181,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Replication Layer / Hybrid Service",
        "subtitle": "Overview",
        "texts": [
            "Requirement for: Persistent Entity Streaming, Static Server Meshing",
            "Solution: Replication Layer (sometimes also called Hybrid service, since the Replication Layer will be moved onto its own server)",
            "Goals:",
            "* Create a new service that is going to sit in-between the player clients, game servers and the EntityGraph database and is responsible for OCS loading decisions, state networking, caching, persisting and initial game world seeding.",
            "* have this service run alongside the game server to get all this functionality online before moving it on its own server for Server Meshing (at which point it is called the Hybrid Service)",
            "* This decouples the Replication and (persistent) state of the game world from the simulation through caching and persistence and allows for server crash recovery.",
            "Approach/Goals:",
            "* The clients and game server(s) will communicate via the Replication Layer and instead of exchanging data directly.",
            "* The service is rolled out in phases:",
            "* In Alpha 3.13 or 3.14, a first version of the Replication Layer might have come online, mainly moving code around in the engine to prepare for later features.",
            "* Alpha 3.15 came online with an in-memory cache (a first taste toward EntityGraph) which introduced the new query system and inventories (including stow/unstow, utilizing Global Database and Global Persistence).",
            "* For Alpha 3.17, the OCS logic that is responsible for loading the game world was moved out of the game server code and into the Replication Layer code. It also came online with improvements to the OCS streaming bubble, allowing clients and servers to load the same entities in parallel and have different streaming bubble sizes for clients (prior they had the same size and the client was only notified after the server completed loading on its side). Speculated: The entity state networking part of OCS might have been moved into the Replication Layer with Alpha 3.17 as well.",
            "* With Alpoha 3.18, the EntityGraph database is hooked up to the Replication Layer (PES first comes online).",
            "* For Static Server Meshing (4.0), the Replication Layer will be moved on its own server, so that multiple game servers can connect to it. Other services will also be part of this central server, which is why this service is called the Hybrid.",
            "* For Dynamic Server Meshing, the Hybrid service will be horizontally scaled, by splitting off individual services, so that they can be scaled independently, serving more clients and servers. This is how server meshing is going to scale up and allow for more and more players in the same game world."
        ],
        "sources": [
            "qa1",
            "cc2",
            "lc1",
            "scr",
            "s209",
            "pn317"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/b/8/9/6/8/e32b789470cb911036004948bfc1200.png"
    },
    {
        "uuid": "873a547e32616479ad71eff412f10cace247aee8",
        "index": 182
    },
    {
        "uuid": "e959cc82838e02ee4b873308b44bb9587deb5413",
        "index": 183,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Time and Synchronization",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* first tests of connecting two game servers together helped identify synchronization issues.",
            "Solution: Rework Time And Synchronization logic (speculated: might have released sometime mid 2021 already)",
            "Requirement for: Server Meshing",
            "Goals:",
            "* ensure that the simulation on both client and server (and soon multiple servers) are better synchronized and networked",
            "Approach:",
            "\"How the engine measures the passage of time underwent a complete overhaul. Accuracy was improved both in the measurement of time and in its synchronization between server and clients. How the engine uses time to update its logic and physics simulation was changed to eliminate errors that could result in simulation time passing differently on the server and clients. Many smaller bugs that had caused timing errors to grow on long-running servers were also fixed. The network synchronization of vehicles and physics objects were updated to take full advantage of the improvements. The accumulated result of all these changes was a significant reduction in latency and desynchronization issues in many areas, even under harsh test conditions for network and server performance. Besides improving the overall player experience, this work was a necessary step towards server meshing, where simulating the game across multiple game servers would have made desynchronization issues due to timing errors worse.\" - Postmortem 3.12"
        ],
        "sources": [
            "cad1",
            "pm1",
            "s209"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "2291a2d75b1f4d6a9ef7d6944846592fed075caf",
        "index": 184
    },
    {
        "uuid": "883d1510fad12cfbc330556539befacd36acb9fc",
        "index": 185,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Connection Process and States",
        "subtitle": "Overview",
        "texts": [
            "\"In a server mesh, a client may connect to many different servers during a game session. Part of the work towards server meshing requires separating the process of connecting a client to a server into distinct stages. These stages can then be executed independently without requiring a client to completely abandon its existing game session. Significant progress has been made towards this although there is more work to be done.\" - Postmortem 3.12",
            "(Speculated: might have released sometime mid 2021 already)"
        ],
        "sources": [
            "pm1",
            "s209"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "c19080c227926154044f0a0cef07b3fe3207d254",
        "index": 186
    },
    {
        "uuid": "50c7ece414c6a42f193f775de79a89c099854edc",
        "index": 187,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Entity Authority",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* The engine/server logic is not designed to have multiple game servers work together because each game server expects to have full control/authority over all entities and not just a small subset (a section/Territory of the level).",
            "Solution: Entity Authority (also known as (Entity) Authority API, initially as If-Statement Refactor) (work began in 2020 and released in Alpha 3.13/3.14)",
            "Requirement for: Server Meshing",
            "Goals:",
            "* allow the game servers in a mesh to share their control over the game world",
            "* let other game servers in the mesh appear as special \"clients\" to a game server to exchange entity states",
            "Approach:",
            "* authority functionality already existed but didn't support multiple game servers, and thus thousands of if-statements were touched in the code",
            "* in programming an if-statement alters the execution of the program to perform different logic. In this case the server needs to know if he has the authority over an entity or not, to either update it or perform a different kind of logic (like receiving state data from another game server).",
            "* \"In preparation for server meshing, the team performed a sweep on the remaining tasks to convert code to the Authority API. Over the last 12 months, there has been a coordinated effort by all teams to update the game-end engine code to this new system. Thanks to their work, a large majority of these tasks have been completed. With a concerted push, weve reduced the number of remaining tasks into single digits\"",
            "- Postmortem 3.12",
            "* \"The Authority API is to let servers know which entities they have authority/control over. [...] in server meshing we need this to distribute control over entities to different servers.",
            "In the original client-server architecture code could just assume that if it was running on the server it would have control over any entity. Because the engine was designed so that clients and servers run a lot of the same code, there were thousands of places in the codebase that needed to check if it was running on a server or not. Some of these checks control systems that are only available to a server but others were really asking if the program had authority over an entity. It's the latter category that needed replacing with the Authority API. However there was no way to tell the cases apart other than looking at every one of the checks individually and deciding if it needed to change.",
            "Being such an enormous amount of work, this conversion was split over all the teams, file by file. This still resulted in hundreds of tasks but thanks to everyone's hard work it's now almost complete. [...]\"",
            "- Clive Johnson, Spectrum Post \"What is the Authority API?\" (Feb 2021)",
            "* the feature might have released mid 2021 already, mainly to test if the engine works the same but with/under the new changes (feature parity). Using Entity Authority under Server Meshing required work on additional features (e.g. Hybrid) which were released later."
        ],
        "sources": [
            "qa1",
            "cad1",
            "s207",
            "s208",
            "s209",
            "src"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "a236f9741d3c7ac28d566376d8142116b26fe5b8",
        "index": 188
    },
    {
        "uuid": "a4214e651e74b9a52a82d09365e1deb1cf8b321d",
        "index": 189,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Atlas",
        "subtitle": "Overview",
        "texts": [
            "Atlas is one of the components of the initial Hybrid Service, but will be its own scalable service later on.",
            "Challenges:",
            "* Entity Authority introduced the functionality of game servers/server nodes to be able to compute only specific entities of the level",
            "* however somethign needs to keep track and assign this authority to the server nodes",
            "Solution: Atlas service",
            "Requirement for: Server Meshing",
            "Goals:",
            "* create a service that manages the Entity Authority for the server nodes of a Shard",
            "Approach:",
            "* Atlas determines and keeps track of which server node has authority over which entity.",
            "* Under Static Server Meshing, it also keeps track of the sections (Territories).",
            "* Atlas tells each game server/server node which entity they have authority over. After that, the Entity Authority logic on the game server is responsible for executing the correct logic on the entity state (run simulation code or not).",
            "* When players and entities (like a ship) move through the level and it enters an area where two game servers overlap (have the same entities loaded), then Authority can be transferred from one game server to another.",
            "* Speculated: this is going to be expanded upon and turned into the Loader Balancer for Dynamic Server Meshing which will try to optimally distribute entities across all game servers."
        ],
        "sources": [
            "qa1",
            "scr"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "2fcc4b2c5d27b0d3e42fdc4ff8a4f32cd5b8e5b8",
        "index": 190
    },
    {
        "uuid": "dd9477e55fd81ef317542a81a422a81e950dcf1b",
        "index": 191,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Replication Layer & Replicant Services",
        "subtitle": "",
        "texts": [
            "Replicant is one of the components of the initial Hybrid Service but will be its own scalable service later on.",
            "Challenges:",
            "* communication between clients and servers has to be scaled up to support more of both in the same shard",
            "Solution: Replication Layer with horizontally scalable Replicant Services",
            "Requirement for: Server Meshing, Persistent Streaming",
            "Goals:",
            "* make the streaming and networking logic scalable for more clients and servers",
            "* have clients/servers partially look into multiple game servers in a performant way",
            "* allow for server recovery and client reconnects feature",
            "* provide a cache for entity state from the EntityGraph database for the clients and server nodes",
            "Approach:",
            "* Parts of the entity networking and OCS logic of the game server is being moved into their own service called the Replicant.",
            "* The servers nodes and player clients don't connect and communicate directly anymore, but instead via the Replicant service (as well as the Gateway service).",
            "* The Replicant will be turned into a horizontally scalable service as well, where each Replicant (with its server nodes) handles a different section of the level. Together, they form the Replication Layer.",
            "* The Replicant includes partial logic of the Entity Component Update Scheduler (ECUS), as well as - speculated/deduced - the StarHash (Starhash Bind Culling) logic of the Entity Streaming Manager, Network Bind Culling and Serialized Variable Culling. Together, they will:",
            "* Manage loading of Object Containers for both client and server (Network Bind Culling, Entity Streaming Manager, StarHash Bind Culling)",
            "* Replication of networked entity state between clients and server nodes (ECUS, Serialized Variable Culling, StarHash Bind Culling)",
            "* As well as persisting entity state changes into the EntityGraph database (Persistence, Persistent Streaming)",
            "* Note: the Replicant does not run code related to game logic, like simulation or physics (as that is the job of the server nodes).",
            "* This allows for the following new functionality:",
            "* Now, game servers won't have to figure out which Object Containers have to be loaded/streamed on both the game server and clients anymore. Instead, the Replicant will figure this out and inform the server nodes and clients instead (and both can load the same entities in parallel which also allows server and clients to have different streaming bubble sizes).",
            "* The server nodes are able to directly send their network updates to the Replicant service once, which then determines which entity states should be send to which client(s) (and maybe other server nodes in the shard) that need it. This would make the Replicant be a mediator and sit between the server nodes, clients and databases.",
            "* The Replicant operates event-driven (not tickrate-driven like game servers), meaning that it directly processes network updates when they are received.",
            "* Additionally, each Replicant contains a cache (in-memory database, iCache) in which parts of the data from the EntityGraph database are copied into. This allows quicker read and write access to entity state data. The Replicant persists its entity state back in the EntityGraph database, so that not a lot of data will be lost in the case if a Replicant crash."
        ],
        "sources": [
            "qa1",
            "cc2",
            "scr"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "75410e27560285bc5b9f47285313706ea4a1a842",
        "index": 192
    },
    {
        "uuid": "60bd25911538cb9f364cf3347e06954c7d0f7faf",
        "index": 193,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Gateway Layer & Gateway Services",
        "subtitle": "Overview",
        "texts": [
            "Gateway is one of the components of the initial Hybrid Service but will be its own scalable service later on.",
            "Challenges:",
            "* communication between clients and server nodes (and Replicants) has to be scaled up to support more of both in the same shard",
            "Solution: Gateway Layer with horizontally scalable Gateway Services",
            "Requirement for: Server Meshing",
            "Goals:",
            "* distribute network updates between multiple clients and Replicants",
            "Approach:",
            "* While the Replicant service is responsible for distributing data between multiple server nodes (\"server node facing\"), the Gateway service is responsible for distributing data between the clients and the Replicant services (\"player client facing\").",
            "* Clients dont connect themselves directly to server nodes anymore nor to the Replicants, but to Gateway services instead.",
            "* The network state updates send from the player clients will be relayed to the correct Relicants by the Gateway services.",
            "* Likewise, the server nodes send their network updates to the Replicant which will then relay it to the relevant Gateway service(s) that need this data. The Gateway service will then relay/replicate this data to the clients that need that specific data.",
            "* Clients might be communicating with multiple Replicants at the same time by having the Gateway establish connections to multiple Gateways at once, exchanging network updates between all of them.",
            "* Highly speculated: When the Gateway service receives network updates from a client, it directly sends it to the clients that require it. It also sends those network updates to the Replicant services that require it, which will relay it further to their server nodes that require it.",
            "* This might allow for low-latency communication between clients, as well as allowing the server nodes to verify player actions and sending validation/rollback updates back to the clients shortly after. Actions already performed on the clients will be rolled back if the server node concludes a different outcome for the player action.",
            "* The Gateway (just like the Replicant) operate event-driven, meaning that they directly process network updates when they are received. Compared to tickrate-driven (updates at periodic intervals, e.g. every 33ms) like the game servers/server nodes operated under."
        ],
        "sources": [
            "qa1"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "8c1c50592a017debeb573b39337fe89e28ff6621",
        "index": 194
    },
    {
        "uuid": "32880143215ce4eacf76f86e980ca9367987bd8e",
        "index": 195,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Scribe",
        "subtitle": "Overview",
        "texts": [
            "Scribe is one of the components of the initial Hybrid Service but will be its own scalable service later on.",
            "Challenges:",
            "* unknown",
            "Solution: Scribe service",
            "Requirement for: Server Meshing",
            "Goals:",
            "* unknown",
            "Approach:",
            "* at this point in time, there is very little know about the Scribe service.",
            "* Speculated: This service might be related to persisting state into the EntityGraph database.",
            "* Speculated: And/Or this might be the Shard Manager service, running under a different name."
        ],
        "sources": [
            "qa1"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "14248255df7b3c239c004623ba2235095a12f257",
        "index": 196
    },
    {
        "uuid": "fc05559168375fe610638bad13bfaf163e7ae57a",
        "index": 197,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Hybrid Service / Replication Layer",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* for all of the server meshing functionality to come online, the newly created services have to come online.",
            "* with such complex interconnected services and infrastructure, the complexity is quite high.",
            "Requirement for: Persistent Streaming, Static Server Meshing",
            "Solution: Hybrid service (initially sometimes referred to as Replication Layer by CIG, although the Replication Layer/Replicant service is just one - but major - part of many which make up the Hybrid)",
            "Goals:",
            "* create a new service that sits in-between the player clients, game servers and the EntityGraph database and is responsible for OCS loading decisions, state networking, caching, persisting, initial game world seeding and managing of entity authority and authority transfers.",
            "Approach/Goals:",
            "* Bring the new services Atlas, Relicant, Gateway & Scribe online, but without the overhead of having to manage and coordinate all of these on their own servers. And instead, reduce the complexity and infrastructure overhead for the initial versions by having all services run on the same server.",
            "* While the mentioned individual services are planned to run on their own, separate servers later on, for the first version of Server Meshing it is easier to have them all on the same server, as the early versions will still be quite small in scope.",
            "* Clients and game servers of a shard will connect themselves to the Hybrid service",
            "* Clients and game servers of a shard will exchange data between each other via the Hybrid service which relays the data between all participants.",
            "* For Dynamic Server Meshing, the Hybrid service is planned to be split up, and each services will be put on its own servers.",
            "* Once that is done, the individual services are going to be horizontally scaled, so that e.g. multiple Replicant and Gateway services are running at the same time. This is how server meshing is going to scale up and allow for more and more players in the same shard.",
            "* The Hybrid service consists of the Replication Layer logic (later Replicant & Gateway services). For more information check out the slide on Replication Layer."
        ],
        "sources": [
            "qa1",
            "cc2",
            "lc1",
            "scr",
            "s209",
            "pn317"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "6ff363082aa8ad6390e522374014327c97664a3f",
        "index": 198
    },
    {
        "uuid": "225534550cc4ad882ee694a7d68b018454a0d21c",
        "index": 199,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Ship Interior Object Container Streaming",
        "subtitle": "Overview",
        "texts": [
            "Solution: Ship Interior OCS, a sub-feature of OCS and an optimization for clients and servers",
            "Requirement for: Server Meshing",
            "Goals:",
            "* \"When complete, streaming interior object containers in and out of ships based on distance will allow vehicles to have a higher performant stage of streaming used at far distances, to reduce CPU cost.\" - Release View",
            "* reduce CPU and memory on client (and servers in server meshing)",
            "Approach (speculated):",
            "* split the exterior and interior of ships into separate Object Containers",
            "* add additional OCS rules for loading and unloading rooms/zones and/or Object Containers of the ship interiors",
            "* the player client does not have to load the interior of far away ships anymore",
            "* speculated: in server meshing, a game servers don't have to load the interior of the ships, which are being computed by another game servers in the mesh/shard",
            "* speculated: rooms with windows will have a different rule compared to rooms which are deeper inside the ships and/or have no windows"
        ],
        "sources": [
            "scr"
        ],
        "originalSlideImageURL": ""
    },
    {
        "uuid": "5a9b9f88f752e249ee27126b960a2c870895dd63",
        "index": 200
    },
    {
        "uuid": "4eb1780fcf13b78cac24b483354d127108f93516",
        "index": 201,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Load Balancer",
        "subtitle": "Overview",
        "texts": [
            "For Server Meshing to become dynamic, there needs to be some kind of logic implemented that will automatically decide how authority over entities is distributed across the game servers. Because under Dynamic Server Meshing, game servers are not supposed to be assigned fixed locations to simulate, and instead are allowed to follow their players around, loading and simulating any part of the game world the players visits. The rule that only one game server is able to have authority over an entity still applies, so server-to-server communication can also happen anywhere in the game world, not just at the predefined borders, like under Static Server Meshing.",
            "However, not a lot is known about this feature and in which form it will be implemented (e.g. utilizing a clustering algorithm).",
            "Speculated: This might also be the functionality of the Atlas service which might take over the role of not only keeping track of authority but also deciding how it should be split."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/4/7/e/2/1/355db594f22b0a0b9995eb9f5151200.png"
    },
    {
        "uuid": "c78d464fa2dfda18ff3ec495969ea3d2c9f6dddb",
        "index": 202
    },
    {
        "uuid": "d0bc753114cab1f82d18e23e332df02a74540375",
        "index": 203,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Replication Layer Version 2 (or \"Hybrid service breakup\")",
        "subtitle": "Overview",
        "texts": [
            "The components of the Hybrid services are going to be move out and into their own services. These services are going to be horizontally scaled, allowing multiple of these services to run alongside each other, allowing for more processing power and bandwidth. These services can then be spun up and shutdown dynamically based on demand. This is how Shards are going to be scaled up, allowing for more players per Shard to potentially reach one single shard per region.",
            "For PES, there is the (Service) Fleet Manager service already in the works which is being designed with scaling game servers and services up and down dynamically in mind."
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/e/0/c/5/e/77429014a178ea9cefc9b3607221200.png"
    },
    {
        "uuid": "0713c224ab386b75a95fc3dc28e2e3efdf10c6eb",
        "index": 204
    },
    {
        "uuid": "021cd9dd69b2ecc861c10d945fc433a699ab0ef7",
        "index": 205,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Specialized Netcode Research and Development",
        "subtitle": "Overview",
        "texts": [
            "To push Shards toward a potential world-wide Single Shard, additional research and development has to be done to mitigate the effects of high latency between services and clients when they are communicated across continental regions. Lag has to be compensated via netcode techniques and smart (re)location of services, requiring additional changes to the service architecture of Server Meshing."
        ],
        "sources": [
            "tw1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/c/9/8/d/3/e49b8704335a3954a1e9b8c25891200.png"
    },
    {
        "uuid": "f02f830554ade56792280e2e8ab54296b9bd1bad",
        "index": 206
    },
    {
        "uuid": "88105467a06364e2e6c6006e2173610c3c4a1ef6",
        "index": 207,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Server Node Multithreading Scaleup",
        "subtitle": "Overview",
        "texts": [
            "CIG plans to highly multithread their simulation so that a single server node can make use of more CPU cores and support more entities/players. This would reduce the total amount of server nodes required and might minimize the need for server-to-server communication as more entities could be put and simulated on the same server node."
        ],
        "sources": [
            "jp1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/d/8/4/a/3/410fb154eb49b613fd9eb0a27691200.png"
    },
    {
        "uuid": "3b3b2916e07cd50918cb4c6388a9dbeab8ad42fb",
        "index": 208
    },
    {
        "uuid": "3e7ea2541d338726835b19556595da07cefba48f",
        "index": 209,
        "imageURLs": [
            "https://media.preziusercontent.com/media/2/8/c/7/7/3d19d26415bbe3bf657881717db.png"
        ],
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Layers/Layering (SPECULATED)",
        "subtitle": "Overview",
        "texts": [
            "SPECULATED: For scenarios where in-game areas are extremely populated, the game might decide to reduce access for other players (like closing jumppoints or AI blockading) or by creating layers that area, meaning that multiple instances of that area exist in parallel within the same shard. Although, it is unclear if this is limited to an area or if the entire game world will be instanced. This solution might take into account friend and foe to put relevant interacting players into the same layer. This would mainly be done to keep the performance on the side of the player client in check. The server side should be fine.",
            "OTHER INTERPRETATION: This might refer to layering of servers and services instead, by which players exchange data with a server in the region of the player (for low latency) and that server exchanges data with a services geographically located in the middle of two regions to exchange data of servers across regions",
            "OR: Players of different shards can meet up by layering areas of the game world."
        ],
        "sources": [
            "qa1",
            "10c2",
            "rtv1"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/0/b/2/4/ace61674dc4beee3cb15438fdee1200.png"
    },
    {
        "uuid": "b6d3c6bf0e353600eb7b57ad460be6f70b8e40bc",
        "index": 210
    },
    {
        "uuid": "cee6a329d2b551f28726492e7e46452614d0a7f3",
        "index": 211,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Projectile Manager",
        "subtitle": "Overview",
        "texts": [
            "Projectiles in the game are entities as well as an item from the new Item 2.0 (Entity Components) system which provides a lot of flexibility.",
            "Challenges:",
            "* projectiles are rather simple in design and computation but the overhead of being traditional entities introduced some issue that were especially noticeable once a very large amount of weapons were fired at the same time/game tick:",
            "* Unnecessarily large memory usage caused by having to allocate the default but unnecessary entity state values",
            "* By design, all spawning entities in the game are blocked until they are finished their spawning process which is not required when it comes to projectiles since they are too simple to be required to go through the entity spawning system. This became an unperformant congestion issue once many projectiles were spawned in the same game tick.",
            "Solution: Rework of the Projectile Manager",
            "Goals:",
            "* improve performance and reduce memory usage to allow for large numbers of simple projectiles in the game",
            "Approach:",
            "* on spawn, detect if the projectile is part of the basic projectile type",
            "* then only create a tiny data structure to hold the necessary values of the projectile instead of a whole entity (very likely: on the code/memory side, it is implemented using a Structure of Arrays or Array of Structures of Arrays)",
            "* in terms of rendering, each projectile is just a simple box with a material and wont be checked for occlusion culling (object not rendered because another object is in front of it blocking the view to the player) since they are already so cheap and not worth using up any additional computation for",
            "* projectile are not network-replicated entities, meaning client and server dont exchange position data each game tick. Only the fire event (and hit event) of a projectile is networked, the position can then be calculated based on that information since the trajectory of a projectile is deterministic/always the same (this will most likely be used for server-to-server communication in Server Meshing as well)"
        ],
        "sources": [
            "atv5",
            "qa1",
            "w3"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/d/d/8/b/3/b1f7a4443a0b046ccac033a7d301200.png"
    },
    {
        "uuid": "acd31539e6f4c96552a1d6644d0b8de84b3c6834",
        "index": 212
    },
    {
        "uuid": "7ae12361afa193a0e3076b3d7c41a631e8d5da58",
        "index": 213,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Actor Networking Rework",
        "subtitle": "",
        "texts": [
            "In the game code, an Actor is an humanoid or animalistic entity in the game which can be controlled by either a Player or by the AI and therefore 'acts' in the game world. Currently, actor movement is client-authoritative, meaning that if a player presses his 'W' button, the player client executes the appropriate action (in this case the player walks forward) and sends the new player position to the server which then sends it to all the other connected player clients to have the action replicated.",
            "Challenges:",
            "* can cause perceived lag and other players teleporting around especially when they have a poor connection to the server",
            "* because the server does not validate the player actions, detecting certain types of cheating becomes more difficult to deal with since the client can just make up any player positions and the server will always consider that data to be correct",
            "* for smooth actor movement and animations there is a 250ms delay injected as a workaround to compensate for lag spikes",
            "Solution: Rework of the Actor Networking ('netcode' for actor movement), split into two parts:",
            "* Upstream: Client-to-Server, released in Alpha 3.6, barely any noticeable effects for players yet",
            "* Downstream: Server-to-Client, functionality will become noticeable for players, slowly and continuously rolled out across a lot of the Alpha 3.x patches, major update and improvements for this in Alpha 3.17.2",
            "Goals:",
            "* make actor movement server-authoritative with client-side prediction (to clarify, this only affecting Actors that does not include ship and weapon networking, those will be separate features/deliverables, partially reusing some of the code)",
            "Approach:",
            "* the player client still executes the movement on its end but also sends a notification containing the pressed button (as an 'action') to the server. The server then executes the action on its side as well then compares its result with the result of the client. If they line up, then everything is okay. If they deviate, then the player client is notified and the position of the player is adjusted to what the server considers correct. This allows the server to validate all player actions.",
            "* other players with bad connections wont teleport around anymore, but if you are the one lagging then you will be the one being teleported around (aka rubber-banding)",
            "* the actor delay will be reduced to something reasonable (~66ms), with improve dead reckoning and state processing",
            "* update: that delay has now been made dynamic, meaning that it will be lowered on low latency connections automatically",
            "* Alpha 3.17.2 \"Enabled new remote movement and new server authoritative position systems. With this update, players should see great improvements with on foot player positions and less jittery behavior while viewing remote player movements.\""
        ],
        "sources": [
            "s104",
            "s304",
            "scr"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/8/1/7/7/96cddd844c99f4581df500e408a1200.png"
    },
    {
        "uuid": "62c206277f4daeed9bdcc88b958cfdd586848c47",
        "index": 214
    },
    {
        "uuid": "9bbef03ffe3a005fabfda86f8f8d51b03d4438f0",
        "index": 215,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Subsumption AI",
        "subtitle": "Overview",
        "texts": [
            "Challenges:",
            "* since Star Citizen universe plans to feature 9 times more NPCs than players as its population, with NPCs being able to perform most jobs and going about their daily lives, the game needs an extensive AI system to accomplish that",
            "Solution: Subsumption AI architecture",
            "Goals:",
            "* create a high-level, bottom-up, behavior-based, objective-oriented NPC system",
            "* let NPCs traverse the game world and perform various actions by making decisions based on their surroundings",
            "Approach:",
            "* more complex tasks/behaviors are build out of multiple simpler sub-tasks/sub-behaviour, creating a \"behavior tree\"",
            "* sub-behaviors are organized into a hierarchy of layers with each layer implementing a particular level of competence.",
            "* Higher levels are able to subsume (integrate/combine) lower levels",
            "* for example if the NPC requires an item then it would 1) search for the item 2) explore the area 3) walk around 4) avoid obstacles. In this case, the higher-level \"explore the area\" would utilize the lower-level competencies like \"avoid obstacles\".",
            "* the NPC is able to adapt to new information while in the process of performing an action by constantly taking in information about the surroundings to then select an appropriate action in a bottom-up fashion",
            "* each individual behavior does not make the NPC look intelligent, only the interaction of multiple behaviors within the environment does",
            "* the Bartender NPCs are a result of this AI system, a first test for various behaviors by interacting with the game world, players and other NPCs",
            "* with server meshing, the NPCs will have to be able to look into multiple servers to make realistic actions",
            "* (speculation: all NPCs will run on their own game server that acts as a client and NPCs communicate back and forth with the game server similar to how player clients do it. this would allow them to look into multiple servers as well)"
        ],
        "sources": [
            "10c1",
            "w10"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/f/6/4/6/b/6fe1c744b8cbca9175ad6a20f0f1200.png"
    },
    {
        "uuid": "01fc378175714b1246dd100bb9bceb2f8f3595b9",
        "index": 216
    },
    {
        "uuid": "a507b82bc34455d09d41e0f02519d3f1a494f816",
        "index": 217,
        "pageIndicators": {
            "current": "1",
            "total": "1"
        },
        "title": "Quantum Economy Simulator",
        "subtitle": "Overview",
        "texts": [
            "A simulation run on a separate server which abstractly simulates thousands of simple AI (Quanta) as well as incorporate player and NPC actions to generate economy data, probability data and missions. All of this data is saved into databases which are then accessed by the game servers to display prices and populate the universe with appropriate objects based on the current state of the economy in that region of space. Also introduces dynamic events and Virtual NPCs to make the game world feel more alive and connected.",
            "Released in its first version in Alpha 3.17 with Quanta generating the prices of quantum fuel, hydrogen fuel and repair services. However, in prior versions it was already used to manage and spawn dynamic events."
        ],
        "sources": [
            "s302"
        ],
        "originalSlideImageURL": "https://media-temporary.preziusercontent.com/frames-public/5/3/f/1/3/7e9b2d54a17900f86d128f4c95a1200.png"
    },
    {
        "uuid": "bc8b8e5b583fe364f8b626b6ca30913fef91f138",
        "index": 218
    },
    {
        "uuid": "e89974b00d8c2ebc519548f6888ab374fb4a62ef",
        "index": 219
    },
    {
        "uuid": "101818252486dd29de94f1f6d4ecab4d4307e31f",
        "index": 220
    },
    {
        "uuid": "6c294c34176fcb176834cfa97210003f4cb9f715",
        "index": 221
    },
    {
        "uuid": "3b509c1100a05158d3d0d97a83cf10f6e12cd243",
        "index": 222
    },
    {
        "uuid": "797731902a614467bd920d717c1790bf2700cc1e",
        "index": 223
    },
    {
        "uuid": "c0950fa5edc1247211858d593442e623bde96bc9",
        "index": 224
    },
    {
        "uuid": "4413ddef7450dc0601d0d4b98d43c1ff6af64a68",
        "index": 225
    },
    {
        "uuid": "3e70f0d879ecf8e96747b338c33b3d950736e092",
        "index": 226
    },
    {
        "uuid": "ef4e31df0cfc6d552caa3f6e656e1c34afb64531",
        "index": 227
    },
    {
        "uuid": "af239902ddcc7771949c23613fe0b3aeba5a9228",
        "index": 228
    },
    {
        "uuid": "2a3b0d65aa02ac6509c19fe65c081f1b1a225082",
        "index": 229
    },
    {
        "uuid": "6ccf38d660f302a84c80461b8c2e79aa018ef941",
        "index": 230
    },
    {
        "uuid": "19cf396ae7cdcabbaba279964a384163a1875b0a",
        "index": 231
    },
    {
        "uuid": "ce6a6dc7755581861a76b2251100ef57caa20ecc",
        "index": 232
    }
]