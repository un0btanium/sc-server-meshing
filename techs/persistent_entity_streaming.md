# Persistent Entity Streaming
### Challenges:
* With the vision of eventually all items physically present and stored in the game world, with physicalized damage and degradation, with thousands of NPCs going about their lifes, with thousands of dynamic missions and events generated by AI and players, with a fully simulated economy, all in a potential single-shard server mesh, all the game information needs to be persisted into databases and then accessed by and networked between the game servers and clients in real-time, requiring an architecture that is able to handle high amounts of data.

__Solution:__ Persistent Entity Streaming (or Persistent Streaming or just PES), complete Interest Management with Full Persistence

__Requirement for:__ Server Meshing, Full Persistence

__Goals:__

* Have a persistent world where everything is stored into databases and loaded (streamed-in) by the game servers, clients and various other services that need that data.
* Allow for all items to be placed anywhere in the game world, persist over large amounts of time and be visited and retrieved later.
* Split State Persistence and State Replication from the Game Simulation by moving that logic out of the game servers and into services.

__Approach:__

* Introduce a highly scalable, cloud-native service backend architecture for high data throughput, low latency, high responsiveness, fault tolerance and crash recovery.
* Besides new logic, this requires a lot of existing logic to be moved out of the game server and into their own services/servers.
* Introduce:
* Two databases: EntityGraph database & Global Database.
* "EntityGraph service": Allows other services to accesses the data of those two databases or move data between the two.
* Replication Layer service: Handles communication between game servers and clients with a cache to store and network the entity state.
* StarSim Economy Simulator: Simulates the economy in a high-level abstraction environment to create a realistic action-reaction system.
* The game server is just left with simulating the game, streaming in all necessary data in and out.
* Uses gRPC (Remote Procedure Calls) for communication between services and game servers (speculated: does not use only RPC).
* The initial persistence solution was attempted with a relational database, which, after internal testing, didnt live up to performance and latency requirements. So, a switch to a graph database and the Replication Layer service commenced end of 2020/early 2021.
* A first version comes online with the Replication Layer and EntityGraph in Alpha 3.18.
* Moving the Replication Layer out of the game server and onto its own server is the next step toward Server Meshing.
### EntityGraph & Global Database & EntityGraph service
For persistence to work, the game data needs to be stored outside of the game servers. Databases are generally used for such a task, because data can be saved to them and later retrived/queried.

The game data of Star Citizen will be stored into two different database:

__EntityGraph database:__

* This is the successor to the pCache database which was introduce when SSOCS came online in Alpha 3.8.
* EntityGraph is a sharded, horizontally scalable graph database.
* It stores the entities which physically exist in the game world.
* Referred to as 'unstowed items'.
* This includes spawned ships, players, coffee cup, etc.
* Each game world has its own EntityGraph database to store its unique state of the game world independently from other game worlds.
* speculated: EntityGraph uses ArangoDB.
* A offline, in-memory version has been developed for the singleplayer game Squadron 42.

__Global Database:__

* The Global Database is the successor to the Long Term Persistence (LTP) database which was introduced shortly after SSOCS came online.
* It consists of three separate data collections:
* Stowed Items
* Wallet (aUEC)
* Reputation
* It stores the entities which are hidden away, only exist inside of inventories or are stored away (e.g. un-/despawned ships). Referred to as 'stowed items'.
* There only exists one Global Database for all game worlds (notice its name containing 'global').
* This allows ships and inventory contents to be accessible from every game world.
* Even if players change to another game world, their stuff will still be available in that game world as well.
### EntityGraph 1/4 - Graph database
EntityGraph is a graph database and is the successor and replacement for the pCache, introduced with Server OCS.

Inside the graph database, game objects are represented as 'nodes'. Connections are made between nodes to symbolize a relation, also called 'edges' in the graph. A ship would be a node and all entities inside - like players and any entities the ship consists of - would also be nodes and be connected to the ship via an edge. The two main strengths of a graph database is that each edge can further describe the relation between two nodes. It also allows for arbitrarily complex queries.

This works perfectly with how Object Containers, Entity Aggregates, Entity Hierarchies and the ZoneSystem create a tree data structure, as well as how this information has to be read and written. While entities are moving around in the game world or interacting with one another, edges between nodes can easily be added and removed as well. This happens when entities move from one zone into another or entities detach/attach to each other. Adding, updating and removing nodes and edges are cheap database operations, which make up the majority of performed actions while simulating the game.

When a new entity is spawned, a new node containing the state of the entity is easily added into the graph. This may also happen when items are taken out of inventories.

![Image](/images/persistent_entity_streaming/image-01.png)
![Image](/images/persistent_entity_streaming/image-02.png)
### INTERMISSION: Database Sharding & Replication 1/3
In terms of storage space, a single database might be able to store the entire universe data. But, in terms of processing power, when one day having to serve dozens or hundreds of game servers, it most definitely cant keep up. Too many read and write requests would hit a single database server. Just like game servers, databases have limited computing power. The solution? Splitting up the persisted data and then distributing the load by horizontally scaling the database across multiple database servers.

![Image](/images/persistent_entity_streaming/image-03.png)
![Image](/images/persistent_entity_streaming/image-04.png)
![Image](/images/persistent_entity_streaming/image-05.png)
### INTERMISSION: Database Sharding & Replication 2/3
For example, the data of each planetary system could be its own Database Shard sitting on its own server. These sub-sets can be created through a sharding key and chunks. With these techniques, a router service is able to determine, in which sub-set and thus database shard a specific piece of data is being read from and written to. Therefore, the (also horizontally scalable) router service makes sure that the read and write requests reach the correct database shard. These router lookups are fast operations compared to the actual queries on the DB shards, so dont add a lot of latency.

__Speculated:__ The amount of sub-sets and thus database shards could be changed or even scaled automatically, depending on the load.

EntityGraph uses the common 'Database Sharding' technique. Instead of one database server containing the entire data, the data is instead logically split into sub-sets. And each sub-set is then stored on its own database server, a Database Shard (Important Note: this has nothing to do with 'Game World Shards' which we will learn more about in the Server Meshing topics).

![Image](/images/persistent_entity_streaming/image-06.png)
![Image](/images/persistent_entity_streaming/image-07.png)
### INTERMISSION: Database Sharding & Replication 3/3
But what would happen if one such database shard crashes or is not reachable? To minimize the loss of data and increase fault tolerance and service availability, EntityGraph also makes use of Database Replication. A data sub-set does not exist on just one database shard, but across additional database shards, which are called Replicas. With this, the same data exist as copies on multiple database servers at once (also known as Data Redundancy). These Replicas can be used to make queries against and loaded from, allowing more requests to hit the EntityGraph.

This also enables database crash recovery functionality: If one database shard goes down, another Replica can take over. The crashed database shard (or Replica) can be spun up again and the data can be copied/replicated back to ensure that there are always enough servers with the copies of the same data available and no data is ever lost.

Going forward we will show and talk about EntityGraph as if it is just one database server. But remember, especially once game worlds are simulated by multiple game servers, that each game world will have its own EntityGraph (collection), consisting of many database shards and router services. (Or - speculated - each game world has its own separate collection in one large EntityGraph database.)

![Image](/images/persistent_entity_streaming/image-08.png)
### EntityGraph 2/4 - Another database: The Global Database
Alongside the graph databases, there exist another database: The Global Database. But why another database? Why the need for two databases?

The reason for this is that each game world has its own state. And this state is saved into its own EntityGraph database (collection) where all physicalized entities of that specific game world are saved into.

In comparison, the Global Database allows specific data to be made available to all game worlds. Therefore there exists only one Global Database for all game worlds, in contrast to one EntityGraph database for each game world. This is required for player ships, all items on the player character or inventories in general, which should be available in the same state, independent on which server the player is currently playing on.

The Global Database stores data related to Reputation, Currency (aUEC) and - most interesting here - Stowed Items. Items are interesting because they can be persisted in either the EntityGraph or the Global Database, depending if they are stowed or unstowed. We have a deeper look about items on the next slide.

### EntityGraph 3/4 - "Entity-Graph service"
Last but not least, besides the two shiny new databases, we also have a new scalable service specifically for facilitating persistence. These new services sit in front of the two databases and allow query requests to be sent from other services/servers that need to access their data. Because some write requests expect changes to be made to both databases as part of one transaction (see Stow & Unstow feature on the next slide), the services handles and relays the appropriate database queries to the databases.

The "services provide translation from our game specific 'query language' into the query operations of the underlying database and translate the results back into a form the game can easily understand. [They] also provide extra reliability and scalability guarantees [...]. What [they dont] do is any form of caching, however it talks to a NoSQL database that performs its own distributed in-memory caching. Not only that but the database is specifically and optimized for graph data which is a much better fit for the type of queries we need to do."

__Note:__ In a followup patch to Alpha 3.18, CIG did introduce caching for Global Database queries in the Entity Graph services: "The team also added inventory query caching to the entity-graph service. This stores the results of inventory queries in a cache to take the load off the database for repeated lookups of the same query, allowing for faster response times and less load on the database. This increases the overall read and write performance of the entity-graph service."

__Note:__ It seems "EntityGraph" can refer to the whole persistence backend solution, just the persistence services, the graph database or even the Global Database/Global Persistence. Confusing, I know.

![Image](/images/persistent_entity_streaming/image-09.png)
### EntityGraph 4/4 - The Stow & Unstow Feature
The Global Database and Stowed Items are important in the context of Persistent Entity Streaming. Even though the goal is a single game world, a "Single Shard", until Server Meshing provides the performance for it, there will still exist multiple game worlds in parallel. Therefore, initially players have to be able to move between game worlds, determined by matchmaking, whenever players log-out and back in. In this case, the player items need to move with our player characters between game worlds. The Global Database enables this capability and makes our data accessible to all game worlds.

For this, the architecture now differentiates between stowed and unstowed items:

* When an item exist physicalized in a game world, it is an unstowed item and is stored in the EntityGraph database of that game world.
* When an item exists inside inventories or is a un/despawned ship - and therefore only interactable from the UI - then they are considered stowed items and are stored in the Global Database.

Therefore, whenever items are moved into an inventory, its EntityGraph node (e.g. Gun #9001 in the image) is removed from the EntityGraph database and a new entry is created into the Global Database (e.g. into the Inventory of Box #123). If an item is taken out of an inventory or a ship is spawned, then it is removed from the Global Database and a new node is created in the EntityGraph (an edge as well). All items stay unique.

![Image](/images/persistent_entity_streaming/image-10.png)
### The Replication Layer 1/2 - Rollout
But PES does not just consist of databases. While, Persistent Entity Streaming feature came online in Alpha 3.18, the groundwork had been layed since at least Alpha 3.13/3.14, where code has been moved around in the game server code to prepare for the Replication Layer. We will talk more about this Replication Layer in a lot more detail in the upcoming Server Meshing topic. For now, all we need to know is, that a lot of the OCS and PES code has been moved into this Replication Layer, with the purpose of being able to move it out and onto its own server later.

After the prep-work in Alpha 3.13 and 3.14, in Alpha 3.15 the Global Database came online and the Replication Layer was setup to make queries against it. Inventories came first online with this update.

In Alpha 3.17, the Replication Layer now copies parts of the game world into its own memory/cache which is then used to run the OCS loading and networking logic.

And then, in Alpha 3.18, the EntityGraph database came online and with it, PES and the persistence of most ingame items/entities. The Replication Layer was setup to both read and write to the EntityGraph database and the Global Database.

![Image](/images/persistent_entity_streaming/image-11.png)
### The Replication Layer 2/2 - Migration onto its own server
After PES released in Alpha 3.18, the next step in the plan was to move the Replication Layer out of the game server and onto its own, separate server.

This is necessary for Server Meshing, as the Replication Layer will be responsible for the communication between the clients and multiple game servers. However, initially, there will only be a single game server connected to the Replication Layer. Only after it is tested and working, will the number of connected game servers be increased, at which point Server Meshing starts to comes online.

Once the Replication Layer is moved out of the game server, it is sometimes also referred to as the Hybrid Service. The Hybrid Service likely contain some additional functionality required to Server Meshing (e.g. it's Atlas component, more on that later).

This shows that Persistent Entity Streaming and Server Meshing are two tightly coupled features and were developed alongside each other. We will go into more detail about the Replication Layer/Hybrid service and the Server Meshing architecture as a whole in the next major topics.

![Image](/images/persistent_entity_streaming/image-12.png)
### Service Migration & Economy Simulation
Last but not least, a lot of additional work was done toward Server Meshing in order to allow multiple game servers to share and access the same data of the game world. Many more - here unnamed - services had to be created, some with entirely new functionality, others with existing logic which had to be moved out of the game server code into own services (e.g. the ATC logic responsible for having players and NPC make request and being assigned a free hangar/landing pad).

Similarly, data which is generated from the Economy Simulation will also be made accessible to all game worlds and game servers. Relevant player actions within all game servers will be fed back into the Economy Simulation, to have all players effect each other, even if they are not all playing in the same game world.

Have a look at the "Service Migration & Creation" minor tech slide for more information.

### Recap of major tech features releasing
* Timeline of major tech in patches:
* Alpha 2.6 Object Containers (preview/feature parity)
* Alpha 3.0 Object Containers, Entity Components, 64bit coordidnates, Zone System, planet tech, new render pipeline, and many more (Full Engine Rework)
* Alpha 3.3 Client OCS
* Alpha 3.8 Server OCS
* Alpha 3.8.2 Long Term Persistence DB (later reworked into the Global DB), less wipes between patches
* Alpha 3.13/3.14 Preparations for the Replication Layer in the game server code
* Alpha 3.15 Release of the Global Database, Global Persistence and Physicalized Items and Inventory (uses RL to make backend DB calls)
* Alpha 3.17 Entity State Networking through the Replication Layer (networking part of OCS moved into RL)
* Alpha 3.18 Gen12 + EntityGraph Database + OC Loading via Replication Layer (+cache for Global DB queries in EntityGraph services, all of OCS in RL)
* Alpha 3.23 Replication Layer moved out of the game server into its own server (Hybrid Service)
* Tech Channel Previews 2024: Static Server Meshing
* Alpha 3.24 Replication Message Queue Refactor
* Alpha 4.0 Static Server Meshing and Pyro
* Alpha 4.X Dynamic Server Meshing V1
